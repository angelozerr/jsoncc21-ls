/* Generated by: JavaCC 21 Parser Generator. JSONCParser.java */
package org.parsers.jsonc;

import java.util.*;
import java.util.concurrent.CancellationException;
import java.util.logging.*;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import static org.parsers.jsonc.JSONCConstants.TokenType.*;
@SuppressWarnings("unused")
public class JSONCParser implements JSONCConstants {
    private static final java.util.logging.Logger LOGGER= Logger.getLogger(JSONCParser.class.getName());
    static {
        LOGGER.setLevel(Level.FINEST);
    }
    public static void setLogLevel(Level level) {
        LOGGER.setLevel(level);
        Logger.getGlobal().getParent().getHandlers()[0].setLevel(level);
    }

    static final int UNLIMITED= Integer.MAX_VALUE;
    // The last token successfully "consumed"     
    Token lastConsumedToken= new Token();
    // We start with a dummy token. REVISIT
    private TokenType nextTokenType;
    private Token currentLookaheadToken;
    private int remainingLookahead;
    private boolean scanToEnd, hitFailure, lastLookaheadSucceeded;
    private String currentlyParsedProduction, currentLookaheadProduction;
    private int lookaheadRoutineNesting;
    private EnumSet<TokenType> outerFollowSet;
    private boolean cancelled;
    public void cancel() {
        cancelled= true;
    }

    public boolean isCancelled() {
        return cancelled;
    }

    /** Generated Lexer. */
    public JSONCLexer token_source;
    public void setInputSource(String inputSource) {
        token_source.setInputSource(inputSource);
    }

    String getInputSource() {
        return token_source.getInputSource();
    }

    //=================================
    // Generated constructors
    //=================================
    public JSONCParser(String inputSource, CharSequence content) {
        this(new JSONCLexer(inputSource, content));
    }

    public JSONCParser(CharSequence content) {
        this("input", content);
    }

    public JSONCParser(String inputSource, Path path) throws IOException {
        this(inputSource, FileLineMap.stringFromBytes(Files.readAllBytes(path)));
    }

    public JSONCParser(Path path) throws IOException {
        this(path.toString(), path);
    }

    public JSONCParser(java.io.InputStream stream) {
        this(new InputStreamReader(stream));
    }

    public JSONCParser(Reader reader) {
        this(new JSONCLexer("input", reader));
    }

    /** Constructor with user supplied Lexer. */
    public JSONCParser(JSONCLexer lexer) {
        token_source= lexer;
        lastConsumedToken.setInputSource(lexer.getInputSource());
    }

    // If tok already has a next field set, it returns that
    // Otherwise, it goes to the token_source, i.e. the Lexer.
    final private Token nextToken(final Token tok) {
        Token result= tok== null?null:
        tok.getNext();
        Token previous= null;
        while (result== null) {
            nextTokenType= null;
            Token next= token_source.getNextToken();
            previous= next;
            if (!next.isUnparsed()) {
                result= next;
            }
            else if (next instanceof InvalidToken) {
                if (debugFaultTolerant) LOGGER.info("Skipping invalid text: "+next.getImage()+" at: "+next.getLocation());
                result= next.getNextToken();
            }
        }
        if (tok!=null) tok.setNext(result);
        nextTokenType= null;
        return result;
    }

    final public Token getNextToken() {
        return getToken(1);
    }

    /** Get the specific Token index ahead in the stream. */
    final public Token getToken(int index) {
        Token t= currentLookaheadToken== null?lastConsumedToken:
        currentLookaheadToken;
        for (int i= 0; i<index; i++) {
            t= nextToken(t);
        }
        return t;
    }

    private final TokenType nextTokenType() {
        if (nextTokenType== null) {
            nextTokenType= nextToken(lastConsumedToken).getType();
        }
        return nextTokenType;
    }

    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:65:1
    final public void Array() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 65 of C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc");
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Array";
        if (pendingRecovery) {
            if (debugFaultTolerant) LOGGER.info("Re-synching to expansion at: C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc:66:5");
            recover$Array();
        }
        Array Array1= null;
        if (buildTree) {
            Array1= new Array();
            Array1.setInputSource(getInputSource());
            openNodeScope(Array1);
        }
        ParseException parseException1= null;
        int callStackSize2= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:66:5
            consumeToken(OPEN_BRACKET, false, follow_set$JSON_javacc$66$5);
            // Code for ZeroOrOne specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:67:5
            if (first_set$JSON_javacc$68$7.contains(nextTokenType())) {
                // Code for NonTerminal specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:7
                pushOntoCallStack("Array", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 68, 7);
                outerFollowSet= follow_set$JSON_javacc$68$7$;
                try {
                    Value();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrMore specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:14
                ParseException parseException16= null;
                int callStackSize17= parsingStack.size();
                try {
                    if (false) throw new ParseException("Never happens!");
                    while (true) {
                        if (!(nextTokenType()== COMMA)) break;
                        Token initialToken19= lastConsumedToken;
                        try {
                            // Code for RegexpRef specified at:
                            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:15
                            consumeToken(COMMA, false, follow_set$JSON_javacc$68$15);
                            // Code for NonTerminal specified at:
                            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:23
                            pushOntoCallStack("Array", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 68, 23);
                            outerFollowSet= follow_set$JSON_javacc$68$23;
                            try {
                                Value();
                            }
                            finally {
                                popCallStack();
                            }
                        }
                        catch(ParseException pe) {
                            if (!isParserTolerant()) throw pe;
                            if (debugFaultTolerant) LOGGER.info("Handling exception. Last consumed token: "+lastConsumedToken.getImage()+" at: "+lastConsumedToken.getLocation());
                            if (initialToken19== lastConsumedToken) {
                                lastConsumedToken= nextToken(lastConsumedToken);
                                //We have to skip a token in this spot or 
                                // we'll be stuck in an infinite loop!
                                lastConsumedToken.setSkipped(true);
                                if (debugFaultTolerant) LOGGER.info("Skipping token "+lastConsumedToken.getImage()+" at: "+lastConsumedToken.getLocation());
                            }
                            if (debugFaultTolerant) LOGGER.info("Repeat re-sync for expansion at: C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc:68:14");
                            recover$JSON_javacc$68$14();
                            if (pendingRecovery) throw pe;
                        }
                    }
                }
                catch(ParseException e) {
                    parseException16= e;
                    if (!isParserTolerant()) throw e;
                    this.pendingRecovery= true;
                }
                finally {
                    restoreCallStack(callStackSize17);
                    this.currentlyParsedProduction= prevProduction;
                }
            }
            // Code for RegexpRef specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:70:5
            EnumSet<TokenType> followSet32= null;
            if (outerFollowSet!=null) {
                followSet32= follow_set$JSON_javacc$70$5.clone();
                followSet32.addAll(outerFollowSet);
            }
            consumeToken(CLOSE_BRACKET, false, followSet32);
        }
        catch(ParseException e) {
            parseException1= e;
            if (isParserTolerant()) this.pendingRecovery= true;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2);
            if (buildTree) {
                if (parseException1== null) {
                    closeNodeScope(Array1, nodeArity()> 1);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException1.getMessage());
                    closeNodeScope(Array1, true);
                    Array1.setDirty(true);
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> Value_FIRST_SET= EnumSet.of(OPEN_BRACKET, OPEN_BRACE, TRUE, FALSE, NULL, STRING_LITERAL, NUMBER);
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:73:1
    final public void Value() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 73 of C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc");
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Value";
        // Code for ExpansionChoice specified at:
        // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:74:5
        if (pendingRecovery) {
            if (debugFaultTolerant) LOGGER.info("Re-synching to expansion at: C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc:74:5");
            recover$Value();
        }
        Value Value2= null;
        if (buildTree) {
            Value2= new Value();
            Value2.setInputSource(getInputSource());
            openNodeScope(Value2);
        }
        ParseException parseException33= null;
        int callStackSize34= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            if (nextTokenType()== TRUE) {
                // Code for RegexpRef specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:74:5
                EnumSet<TokenType> followSet42= null;
                if (outerFollowSet!=null) {
                    followSet42= follow_set$JSON_javacc$74$5.clone();
                    followSet42.addAll(outerFollowSet);
                }
                consumeToken(TRUE, false, followSet42);
            }
            else if (nextTokenType()== FALSE) {
                // Code for RegexpRef specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:76:5
                EnumSet<TokenType> followSet49= null;
                if (outerFollowSet!=null) {
                    followSet49= follow_set$JSON_javacc$76$5.clone();
                    followSet49.addAll(outerFollowSet);
                }
                consumeToken(FALSE, false, followSet49);
            }
            else if (nextTokenType()== NULL) {
                // Code for RegexpRef specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:78:5
                EnumSet<TokenType> followSet56= null;
                if (outerFollowSet!=null) {
                    followSet56= follow_set$JSON_javacc$78$5.clone();
                    followSet56.addAll(outerFollowSet);
                }
                consumeToken(NULL, false, followSet56);
            }
            else if (nextTokenType()== STRING_LITERAL) {
                // Code for RegexpRef specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:80:5
                EnumSet<TokenType> followSet63= null;
                if (outerFollowSet!=null) {
                    followSet63= follow_set$JSON_javacc$80$5.clone();
                    followSet63.addAll(outerFollowSet);
                }
                consumeToken(STRING_LITERAL, false, followSet63);
            }
            else if (nextTokenType()== NUMBER) {
                // Code for RegexpRef specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:82:5
                EnumSet<TokenType> followSet70= null;
                if (outerFollowSet!=null) {
                    followSet70= follow_set$JSON_javacc$82$5.clone();
                    followSet70.addAll(outerFollowSet);
                }
                consumeToken(NUMBER, false, followSet70);
            }
            else if (nextTokenType()== OPEN_BRACKET) {
                // Code for NonTerminal specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:84:5
                pushOntoCallStack("Value", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 84, 5);
                try {
                    Array();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== OPEN_BRACE) {
                // Code for NonTerminal specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:86:5
                pushOntoCallStack("Value", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 86, 5);
                try {
                    JSONObject();
                }
                finally {
                    popCallStack();
                }
            }
            else {
                pushOntoCallStack("Value", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 74, 5);
                throw new ParseException(this, Value_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException33= e;
            if (isParserTolerant()) this.pendingRecovery= true;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize34);
            if (buildTree) {
                if (parseException33== null) {
                    closeNodeScope(Value2, nodeArity()> 1);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException33.getMessage());
                    closeNodeScope(Value2, true);
                    Value2.setDirty(true);
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:1
    final public void KeyValuePair() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 89 of C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc");
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "KeyValuePair";
        if (pendingRecovery) {
            if (debugFaultTolerant) LOGGER.info("Re-synching to expansion at: C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc:89:16");
            recover$KeyValuePair();
        }
        KeyValuePair KeyValuePair3= null;
        if (buildTree) {
            KeyValuePair3= new KeyValuePair();
            KeyValuePair3.setInputSource(getInputSource());
            openNodeScope(KeyValuePair3);
        }
        ParseException parseException83= null;
        int callStackSize84= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:16
            consumeToken(STRING_LITERAL, false, follow_set$JSON_javacc$89$16);
            // Code for RegexpRef specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:33
            consumeToken(COLON, false, follow_set$JSON_javacc$89$33);
            // Code for NonTerminal specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:41
            pushOntoCallStack("KeyValuePair", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 89, 41);
            try {
                Value();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException83= e;
            if (isParserTolerant()) this.pendingRecovery= true;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize84);
            if (buildTree) {
                if (parseException83== null) {
                    closeNodeScope(KeyValuePair3, nodeArity()> 1);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException83.getMessage());
                    closeNodeScope(KeyValuePair3, true);
                    KeyValuePair3.setDirty(true);
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:91:1
    final public void JSONObject() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 91 of C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc");
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "JSONObject";
        if (pendingRecovery) {
            if (debugFaultTolerant) LOGGER.info("Re-synching to expansion at: C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc:92:5");
            recover$JSONObject();
        }
        JSONObject JSONObject4= null;
        if (buildTree) {
            JSONObject4= new JSONObject();
            JSONObject4.setInputSource(getInputSource());
            openNodeScope(JSONObject4);
        }
        ParseException parseException95= null;
        int callStackSize96= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:92:5
            if (pendingRecovery) {
                if (debugFaultTolerant) LOGGER.info("Re-synching to expansion at: C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc:92:5");
                recover$JSON_javacc$92$5();
            }
            consumeToken(OPEN_BRACE, true, follow_set$JSON_javacc$92$5);
            // Code for ZeroOrOne specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:93:5
            if (nextTokenType()== STRING_LITERAL) {
                // Code for NonTerminal specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:9
                pushOntoCallStack("JSONObject", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 94, 9);
                outerFollowSet= follow_set$JSON_javacc$94$9;
                try {
                    KeyValuePair();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrMore specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:22
                ParseException parseException110= null;
                int callStackSize111= parsingStack.size();
                try {
                    if (false) throw new ParseException("Never happens!");
                    while (true) {
                        if (!(nextTokenType()== COMMA)) break;
                        Token initialToken113= lastConsumedToken;
                        try {
                            // Code for RegexpStringLiteral specified at:
                            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:23
                            consumeToken(COMMA, false, follow_set$JSON_javacc$94$23);
                            // Code for NonTerminal specified at:
                            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:27
                            pushOntoCallStack("JSONObject", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 94, 27);
                            outerFollowSet= follow_set$JSON_javacc$94$27;
                            try {
                                KeyValuePair();
                            }
                            finally {
                                popCallStack();
                            }
                        }
                        catch(ParseException pe) {
                            if (!isParserTolerant()) throw pe;
                            if (debugFaultTolerant) LOGGER.info("Handling exception. Last consumed token: "+lastConsumedToken.getImage()+" at: "+lastConsumedToken.getLocation());
                            if (initialToken113== lastConsumedToken) {
                                lastConsumedToken= nextToken(lastConsumedToken);
                                //We have to skip a token in this spot or 
                                // we'll be stuck in an infinite loop!
                                lastConsumedToken.setSkipped(true);
                                if (debugFaultTolerant) LOGGER.info("Skipping token "+lastConsumedToken.getImage()+" at: "+lastConsumedToken.getLocation());
                            }
                            if (debugFaultTolerant) LOGGER.info("Repeat re-sync for expansion at: C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc:94:22");
                            recover$JSON_javacc$94$22();
                            if (pendingRecovery) throw pe;
                        }
                    }
                }
                catch(ParseException e) {
                    parseException110= e;
                    if (!isParserTolerant()) throw e;
                    this.pendingRecovery= true;
                }
                finally {
                    restoreCallStack(callStackSize111);
                    this.currentlyParsedProduction= prevProduction;
                }
            }
            // Code for RegexpRef specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:96:5
            if (pendingRecovery) {
                if (debugFaultTolerant) LOGGER.info("Re-synching to expansion at: C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc:96:5");
                recover$JSON_javacc$96$5();
            }
            EnumSet<TokenType> followSet126= null;
            if (outerFollowSet!=null) {
                followSet126= follow_set$JSON_javacc$96$5.clone();
                followSet126.addAll(outerFollowSet);
            }
            consumeToken(CLOSE_BRACE, true, followSet126);
        }
        catch(ParseException e) {
            parseException95= e;
            if (isParserTolerant()) this.pendingRecovery= true;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize96);
            if (buildTree) {
                if (parseException95== null) {
                    closeNodeScope(JSONObject4, nodeArity()> 1);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException95.getMessage());
                    closeNodeScope(JSONObject4, true);
                    JSONObject4.setDirty(true);
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    private void recover$Array() {
        Token initialToken= lastConsumedToken;
        List<Token> skippedTokens= new ArrayList<> ();
        boolean success= false;
        while (lastConsumedToken.getType()!=EOF) {
            if (nextTokenType()== OPEN_BRACKET) {
                success= true;
                break;
            }
            if (lastConsumedToken!=initialToken) skippedTokens.add(lastConsumedToken);
            lastConsumedToken= nextToken(lastConsumedToken);
        }
        if (!success&&!skippedTokens.isEmpty()) {
            lastConsumedToken= initialToken;
        }
        if (success&&!skippedTokens.isEmpty()) {
            InvalidNode iv= new InvalidNode();
            for (Token tok : skippedTokens) {
                iv.addChild(tok);
            }
            if (debugFaultTolerant) {
                LOGGER.info("Skipping "+skippedTokens.size()+" tokens starting at: "+skippedTokens.get(0).getLocation());
            }
            pushNode(iv);
        }
        pendingRecovery= !success;
    }

    private void recover$JSON_javacc$68$14() {
        Token initialToken= lastConsumedToken;
        List<Token> skippedTokens= new ArrayList<> ();
        boolean success= false;
        while (lastConsumedToken.getType()!=EOF) {
            if (nextTokenType()== COMMA) {
                success= true;
                break;
            }
            if (nextTokenType()== CLOSE_BRACKET) {
                success= true;
                break;
            }
            if (outerFollowSet!=null) {
                if (outerFollowSet.contains(nextTokenType())) {
                    success= true;
                    break;
                }
            }
            if (lastConsumedToken!=initialToken) skippedTokens.add(lastConsumedToken);
            lastConsumedToken= nextToken(lastConsumedToken);
        }
        if (!success&&!skippedTokens.isEmpty()) {
            lastConsumedToken= initialToken;
        }
        if (success&&!skippedTokens.isEmpty()) {
            InvalidNode iv= new InvalidNode();
            for (Token tok : skippedTokens) {
                iv.addChild(tok);
            }
            if (debugFaultTolerant) {
                LOGGER.info("Skipping "+skippedTokens.size()+" tokens starting at: "+skippedTokens.get(0).getLocation());
            }
            pushNode(iv);
        }
        pendingRecovery= !success;
    }

    private void recover$Value() {
        Token initialToken= lastConsumedToken;
        List<Token> skippedTokens= new ArrayList<> ();
        boolean success= false;
        while (lastConsumedToken.getType()!=EOF) {
            if (Value_FIRST_SET.contains(nextTokenType())) {
                success= true;
                break;
            }
            if (lastConsumedToken!=initialToken) skippedTokens.add(lastConsumedToken);
            lastConsumedToken= nextToken(lastConsumedToken);
        }
        if (!success&&!skippedTokens.isEmpty()) {
            lastConsumedToken= initialToken;
        }
        if (success&&!skippedTokens.isEmpty()) {
            InvalidNode iv= new InvalidNode();
            for (Token tok : skippedTokens) {
                iv.addChild(tok);
            }
            if (debugFaultTolerant) {
                LOGGER.info("Skipping "+skippedTokens.size()+" tokens starting at: "+skippedTokens.get(0).getLocation());
            }
            pushNode(iv);
        }
        pendingRecovery= !success;
    }

    private void recover$KeyValuePair() {
        Token initialToken= lastConsumedToken;
        List<Token> skippedTokens= new ArrayList<> ();
        boolean success= false;
        while (lastConsumedToken.getType()!=EOF) {
            if (nextTokenType()== STRING_LITERAL) {
                success= true;
                break;
            }
            if (lastConsumedToken!=initialToken) skippedTokens.add(lastConsumedToken);
            lastConsumedToken= nextToken(lastConsumedToken);
        }
        if (!success&&!skippedTokens.isEmpty()) {
            lastConsumedToken= initialToken;
        }
        if (success&&!skippedTokens.isEmpty()) {
            InvalidNode iv= new InvalidNode();
            for (Token tok : skippedTokens) {
                iv.addChild(tok);
            }
            if (debugFaultTolerant) {
                LOGGER.info("Skipping "+skippedTokens.size()+" tokens starting at: "+skippedTokens.get(0).getLocation());
            }
            pushNode(iv);
        }
        pendingRecovery= !success;
    }

    private void recover$JSONObject() {
        Token initialToken= lastConsumedToken;
        List<Token> skippedTokens= new ArrayList<> ();
        boolean success= false;
        while (lastConsumedToken.getType()!=EOF) {
            if (nextTokenType()== OPEN_BRACE) {
                success= true;
                break;
            }
            if (lastConsumedToken!=initialToken) skippedTokens.add(lastConsumedToken);
            lastConsumedToken= nextToken(lastConsumedToken);
        }
        if (!success&&!skippedTokens.isEmpty()) {
            lastConsumedToken= initialToken;
        }
        if (success&&!skippedTokens.isEmpty()) {
            InvalidNode iv= new InvalidNode();
            for (Token tok : skippedTokens) {
                iv.addChild(tok);
            }
            if (debugFaultTolerant) {
                LOGGER.info("Skipping "+skippedTokens.size()+" tokens starting at: "+skippedTokens.get(0).getLocation());
            }
            pushNode(iv);
        }
        pendingRecovery= !success;
    }

    private void recover$JSON_javacc$92$5() {
        Token initialToken= lastConsumedToken;
        List<Token> skippedTokens= new ArrayList<> ();
        boolean success= false;
        while (lastConsumedToken.getType()!=EOF) {
            if (nextTokenType()== OPEN_BRACE) {
                success= true;
                break;
            }
            if (lastConsumedToken!=initialToken) skippedTokens.add(lastConsumedToken);
            lastConsumedToken= nextToken(lastConsumedToken);
        }
        if (!success&&!skippedTokens.isEmpty()) {
            lastConsumedToken= initialToken;
        }
        if (success&&!skippedTokens.isEmpty()) {
            InvalidNode iv= new InvalidNode();
            for (Token tok : skippedTokens) {
                iv.addChild(tok);
            }
            if (debugFaultTolerant) {
                LOGGER.info("Skipping "+skippedTokens.size()+" tokens starting at: "+skippedTokens.get(0).getLocation());
            }
            pushNode(iv);
        }
        pendingRecovery= !success;
    }

    private void recover$JSON_javacc$94$22() {
        Token initialToken= lastConsumedToken;
        List<Token> skippedTokens= new ArrayList<> ();
        boolean success= false;
        while (lastConsumedToken.getType()!=EOF) {
            if (nextTokenType()== COMMA) {
                success= true;
                break;
            }
            if (nextTokenType()== CLOSE_BRACE) {
                success= true;
                break;
            }
            if (outerFollowSet!=null) {
                if (outerFollowSet.contains(nextTokenType())) {
                    success= true;
                    break;
                }
            }
            if (lastConsumedToken!=initialToken) skippedTokens.add(lastConsumedToken);
            lastConsumedToken= nextToken(lastConsumedToken);
        }
        if (!success&&!skippedTokens.isEmpty()) {
            lastConsumedToken= initialToken;
        }
        if (success&&!skippedTokens.isEmpty()) {
            InvalidNode iv= new InvalidNode();
            for (Token tok : skippedTokens) {
                iv.addChild(tok);
            }
            if (debugFaultTolerant) {
                LOGGER.info("Skipping "+skippedTokens.size()+" tokens starting at: "+skippedTokens.get(0).getLocation());
            }
            pushNode(iv);
        }
        pendingRecovery= !success;
    }

    private void recover$JSON_javacc$96$5() {
        Token initialToken= lastConsumedToken;
        List<Token> skippedTokens= new ArrayList<> ();
        boolean success= false;
        while (lastConsumedToken.getType()!=EOF) {
            if (nextTokenType()== CLOSE_BRACE) {
                success= true;
                break;
            }
            if (lastConsumedToken!=initialToken) skippedTokens.add(lastConsumedToken);
            lastConsumedToken= nextToken(lastConsumedToken);
        }
        if (!success&&!skippedTokens.isEmpty()) {
            lastConsumedToken= initialToken;
        }
        if (success&&!skippedTokens.isEmpty()) {
            InvalidNode iv= new InvalidNode();
            for (Token tok : skippedTokens) {
                iv.addChild(tok);
            }
            if (debugFaultTolerant) {
                LOGGER.info("Skipping "+skippedTokens.size()+" tokens starting at: "+skippedTokens.get(0).getLocation());
            }
            pushNode(iv);
        }
        pendingRecovery= !success;
    }

    static private final EnumSet<TokenType> first_set$JSON_javacc$68$7= EnumSet.of(OPEN_BRACKET, OPEN_BRACE, TRUE, FALSE, NULL, STRING_LITERAL, NUMBER);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$66$5= EnumSet.of(OPEN_BRACKET, CLOSE_BRACKET, OPEN_BRACE, TRUE, FALSE, NULL, STRING_LITERAL, NUMBER);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$68$7$= EnumSet.of(COMMA, CLOSE_BRACKET);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$68$15= EnumSet.of(OPEN_BRACKET, OPEN_BRACE, TRUE, FALSE, NULL, STRING_LITERAL, NUMBER);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$68$23= EnumSet.of(CLOSE_BRACKET);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$70$5= EnumSet.noneOf(TokenType.class);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$74$5= EnumSet.noneOf(TokenType.class);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$76$5= EnumSet.noneOf(TokenType.class);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$78$5= EnumSet.noneOf(TokenType.class);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$80$5= EnumSet.noneOf(TokenType.class);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$82$5= EnumSet.noneOf(TokenType.class);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$89$16= EnumSet.of(COLON);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$89$33= EnumSet.of(OPEN_BRACKET, OPEN_BRACE, TRUE, FALSE, NULL, STRING_LITERAL, NUMBER);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$92$5= EnumSet.of(CLOSE_BRACE, STRING_LITERAL);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$94$9= EnumSet.of(COMMA, CLOSE_BRACE);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$94$23= EnumSet.of(STRING_LITERAL);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$94$27= EnumSet.of(CLOSE_BRACE);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$96$5= EnumSet.noneOf(TokenType.class);
    private final boolean scanToken(TokenType expectedType) {
        currentLookaheadToken= nextToken(currentLookaheadToken);
        TokenType type= currentLookaheadToken.getType();
        if (type!=expectedType) return lastLookaheadSucceeded= false;
        if (remainingLookahead!=UNLIMITED) remainingLookahead--;
        return lastLookaheadSucceeded= true;
    }

    private final boolean scanToken(EnumSet<TokenType> types) {
        currentLookaheadToken= nextToken(currentLookaheadToken);
        TokenType type= currentLookaheadToken.getType();
        if (!types.contains(type)) return lastLookaheadSucceeded= false;
        if (remainingLookahead!=UNLIMITED) remainingLookahead--;
        //     if (type == upToTokenType) remainingLookahead = 0;
        return lastLookaheadSucceeded= true;
    }

    //====================================
    // Lookahead Routines
    //====================================
    // scanahead routine for expansion at: 
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:7
    // BuildScanRoutine macro
    private final boolean check$JSON_javacc$68$7() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:7
            pushOntoLookaheadStack("Array", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 68, 7);
            String prevProduction127= currentLookaheadProduction;
            currentLookaheadProduction= "Value";
            scanToEnd= false;
            try {
                if (!check$Value()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction127;
            }
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for ZeroOrMore specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:14
            while (remainingLookahead> 0&&!hitFailure) {
                Token token128= currentLookaheadToken;
                if (!check$JSON_javacc$68$15()) {
                    currentLookaheadToken= token128;
                    break;
                }
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:15
    // BuildScanRoutine macro
    private final boolean check$JSON_javacc$68$15() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:15
            if (!scanToken(COMMA)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:23
            pushOntoLookaheadStack("Array", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 68, 23);
            String prevProduction129= currentLookaheadProduction;
            currentLookaheadProduction= "Value";
            scanToEnd= true;
            try {
                if (!check$Value()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction129;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:84:5
    // BuildScanRoutine macro
    private final boolean check$JSON_javacc$84$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:84:5
            pushOntoLookaheadStack("Value", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 84, 5);
            String prevProduction130= currentLookaheadProduction;
            currentLookaheadProduction= "Array";
            scanToEnd= false;
            try {
                if (!check$Array()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction130;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:86:5
    // BuildScanRoutine macro
    private final boolean check$JSON_javacc$86$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:86:5
            pushOntoLookaheadStack("Value", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 86, 5);
            String prevProduction131= currentLookaheadProduction;
            currentLookaheadProduction= "JSONObject";
            scanToEnd= false;
            try {
                if (!check$JSONObject()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction131;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:9
    // BuildScanRoutine macro
    private final boolean check$JSON_javacc$94$9() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:9
            pushOntoLookaheadStack("JSONObject", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 94, 9);
            String prevProduction132= currentLookaheadProduction;
            currentLookaheadProduction= "KeyValuePair";
            scanToEnd= false;
            try {
                if (!check$KeyValuePair()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction132;
            }
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for ZeroOrMore specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:22
            while (remainingLookahead> 0&&!hitFailure) {
                Token token133= currentLookaheadToken;
                if (!check$JSON_javacc$94$23()) {
                    currentLookaheadToken= token133;
                    break;
                }
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:23
    // BuildScanRoutine macro
    private final boolean check$JSON_javacc$94$23() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:23
            if (!scanToken(COMMA)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:27
            pushOntoLookaheadStack("JSONObject", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 94, 27);
            String prevProduction134= currentLookaheadProduction;
            currentLookaheadProduction= "KeyValuePair";
            scanToEnd= true;
            try {
                if (!check$KeyValuePair()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction134;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Array() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:66:5
        if (!scanToken(OPEN_BRACKET)) return lastLookaheadSucceeded= false;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ZeroOrOne specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:67:5
        Token token135= currentLookaheadToken;
        if (!check$JSON_javacc$68$7()) currentLookaheadToken= token135;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:70:5
        if (!scanToken(CLOSE_BRACKET)) return lastLookaheadSucceeded= false;
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Value() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ExpansionChoice specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:74:5
        Token token136= currentLookaheadToken;
        int remainingLookahead136= remainingLookahead;
        boolean hitFailure136= hitFailure;
        if (!scanToken(TRUE)) {
            currentLookaheadToken= token136;
            remainingLookahead= remainingLookahead136;
            hitFailure= hitFailure136;
            if (!scanToken(FALSE)) {
                currentLookaheadToken= token136;
                remainingLookahead= remainingLookahead136;
                hitFailure= hitFailure136;
                if (!scanToken(NULL)) {
                    currentLookaheadToken= token136;
                    remainingLookahead= remainingLookahead136;
                    hitFailure= hitFailure136;
                    if (!scanToken(STRING_LITERAL)) {
                        currentLookaheadToken= token136;
                        remainingLookahead= remainingLookahead136;
                        hitFailure= hitFailure136;
                        if (!scanToken(NUMBER)) {
                            currentLookaheadToken= token136;
                            remainingLookahead= remainingLookahead136;
                            hitFailure= hitFailure136;
                            if (!check$JSON_javacc$84$5()) {
                                currentLookaheadToken= token136;
                                remainingLookahead= remainingLookahead136;
                                hitFailure= hitFailure136;
                                if (!check$JSON_javacc$86$5()) {
                                    currentLookaheadToken= token136;
                                    remainingLookahead= remainingLookahead136;
                                    hitFailure= hitFailure136;
                                    return lastLookaheadSucceeded= false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$KeyValuePair() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:16
        if (!scanToken(STRING_LITERAL)) return lastLookaheadSucceeded= false;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:33
        if (!scanToken(COLON)) return lastLookaheadSucceeded= false;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:41
        pushOntoLookaheadStack("KeyValuePair", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 89, 41);
        String prevProduction137= currentLookaheadProduction;
        currentLookaheadProduction= "Value";
        scanToEnd= true;
        try {
            if (!check$Value()) return lastLookaheadSucceeded= false;
        }
        finally {
            popLookaheadStack();
            currentLookaheadProduction= prevProduction137;
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$JSONObject() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:92:5
        if (!scanToken(OPEN_BRACE)) return lastLookaheadSucceeded= false;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ZeroOrOne specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:93:5
        Token token138= currentLookaheadToken;
        if (!check$JSON_javacc$94$9()) currentLookaheadToken= token138;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:96:5
        if (!scanToken(CLOSE_BRACE)) return lastLookaheadSucceeded= false;
        return lastLookaheadSucceeded= true;
    }

    private boolean trace_enabled= false;
    public void setTracingEnabled(boolean tracingEnabled) {
        trace_enabled= tracingEnabled;
    }

    /**
 * @deprecated Use #setTracingEnabled
 */
    @Deprecated public void enable_tracing() {
        setTracingEnabled(true);
    }

    /**
 * @deprecated Use #setTracingEnabled
 */
    @Deprecated public void disable_tracing() {
        setTracingEnabled(false);
    }

    ArrayList<NonTerminalCall> parsingStack= new ArrayList<> ();
    private ArrayList<NonTerminalCall> lookaheadStack= new ArrayList<> ();
    /**
 * Inner class that represents entering a grammar production
 */
    class NonTerminalCall {
        final String sourceFile;
        final String productionName;
        final int line, column;
        // We actually only use this when we're working with the LookaheadStack
        final boolean scanToEnd;
        final EnumSet<TokenType> followSet;
        NonTerminalCall(String sourceFile, String productionName, int line, int column) {
            this.sourceFile= sourceFile;
            this.productionName= productionName;
            this.line= line;
            this.column= column;
            this.scanToEnd= JSONCParser.this.scanToEnd;
            this.followSet= JSONCParser.this.outerFollowSet;
        }

        StackTraceElement createStackTraceElement() {
            return new StackTraceElement("JSONCParser", productionName, sourceFile, line);
        }

        void dump(PrintStream ps) {
            ps.println(productionName+":"+line+":"+column);
        }

    }
    private final void pushOntoCallStack(String methodName, String fileName, int line, int column) {
        parsingStack.add(new NonTerminalCall(fileName, methodName, line, column));
    }

    private final void popCallStack() {
        NonTerminalCall ntc= parsingStack.remove(parsingStack.size()-1);
        this.outerFollowSet= ntc.followSet;
    }

    private final void restoreCallStack(int prevSize) {
        while (parsingStack.size()> prevSize) {
            popCallStack();
        }
    }

    private final void pushOntoLookaheadStack(String methodName, String fileName, int line, int column) {
        lookaheadStack.add(new NonTerminalCall(fileName, methodName, line, column));
    }

    private final void popLookaheadStack() {
        NonTerminalCall ntc= lookaheadStack.remove(lookaheadStack.size()-1);
        this.scanToEnd= ntc.scanToEnd;
    }

    void dumpLookaheadStack(PrintStream ps) {
        ListIterator<NonTerminalCall> it= lookaheadStack.listIterator(lookaheadStack.size());
        while (it.hasPrevious()) {
            it.previous().dump(ps);
        }
    }

    void dumpCallStack(PrintStream ps) {
        ListIterator<NonTerminalCall> it= parsingStack.listIterator(parsingStack.size());
        while (it.hasPrevious()) {
            it.previous().dump(ps);
        }
    }

    void dumpLookaheadCallStack(PrintStream ps) {
        ps.println("Current Parser Production is: "+currentlyParsedProduction);
        ps.println("Current Lookahead Production is: "+currentLookaheadProduction);
        ps.println("---Lookahead Stack---");
        dumpLookaheadStack(ps);
        ps.println("---Call Stack---");
        dumpCallStack(ps);
    }

    private boolean tolerantParsing= true;
    // Are we pending a recovery routine to
    // get back on the rails?
    private boolean pendingRecovery;
    private boolean debugFaultTolerant= true;
    public boolean isParserTolerant() {
        return tolerantParsing;
    }

    public void setParserTolerant(boolean tolerantParsing) {
        this.tolerantParsing= tolerantParsing;
    }

    private Token consumeToken(TokenType expectedType, boolean tolerant, EnumSet<TokenType> followSet) throws ParseException {
        Token oldToken= lastConsumedToken;
        Token nextToken= nextToken(lastConsumedToken);
        if (nextToken.getType()!=expectedType) {
            nextToken= handleUnexpectedTokenType(expectedType, nextToken, tolerant, followSet);
        }
        this.lastConsumedToken= nextToken;
        this.nextTokenType= null;
        if (buildTree&&tokensAreNodes) {
            pushNode(lastConsumedToken);
        }
        if (trace_enabled) LOGGER.info("Consumed token of type "+lastConsumedToken.getType()+" from "+lastConsumedToken.getLocation());
        return lastConsumedToken;
    }

    private Token handleUnexpectedTokenType(TokenType expectedType, Token nextToken, boolean tolerant, EnumSet<TokenType> followSet) throws ParseException {
        if (!this.tolerantParsing) {
            throw new ParseException(nextToken, EnumSet.of(expectedType), parsingStack);
        }
        Token nextNext= nextToken(nextToken);
        if (nextNext.getType()== expectedType) {
            nextToken.setSkipped(true);
            if (debugFaultTolerant) LOGGER.info("Skipping token of type: "+nextToken.getType()+" at: "+nextToken.getLocation());
            pushNode(nextToken);
            lastConsumedToken.setNext(nextNext);
            return nextNext;
        }
        if (tolerant||followSet== null||followSet.contains(nextToken.getType())) {
            Token virtualToken= Token.newToken(expectedType, "VIRTUAL "+expectedType, lastConsumedToken);
            virtualToken.setVirtual(true);
            virtualToken.copyLocationInfo(nextToken);
            virtualToken.setNext(nextToken);
            lastConsumedToken.setNext(virtualToken);
            if (debugFaultTolerant) LOGGER.info("Inserting virtual token of type: "+expectedType+" at "+virtualToken.getLocation());
            return virtualToken;
        }
        throw new ParseException(nextToken, EnumSet.of(expectedType), parsingStack);
    }

    private class ParseState {
        Token lastConsumed;
        ArrayList<NonTerminalCall> parsingStack;
        NodeScope nodeScope;
        ParseState() {
            this.lastConsumed= JSONCParser.this.lastConsumedToken;
            this.parsingStack= (ArrayList<NonTerminalCall> ) JSONCParser.this.parsingStack.clone();
            this.nodeScope= (NodeScope) currentNodeScope.clone();
        }

    }
    private boolean buildTree= true;
    private boolean tokensAreNodes= true;
    private boolean unparsedTokensAreNodes= false;
    public void setUnparsedTokensAreNodes(boolean unparsedTokensAreNodes) {
        this.unparsedTokensAreNodes= unparsedTokensAreNodes;
    }

    public void setTokensAreNodes(boolean tokensAreNodes) {
        this.tokensAreNodes= tokensAreNodes;
    }

    NodeScope currentNodeScope= new NodeScope();
    /** 
	 * Returns the root node of the AST.  It only makes sense to call
	 * this after a successful parse. 
	 */
    public Node rootNode() {
        return currentNodeScope.rootNode();
    }

    /**
     * push a node onto the top of the node stack
     */
    public void pushNode(Node n) {
        currentNodeScope.add(n);
    }

    /** 
     * Returns the node on the top of the stack, and remove it from the
     * stack.  
     */
    public Node popNode() {
        return currentNodeScope.pop();
    }

    /** 
     * Returns the node currently on the top of the stack. 
     */
    public Node peekNode() {
        return currentNodeScope.peek();
    }

    /**
     * Puts the node on the top of the stack. However, unlike pushNode()
     * it replaces the node that is currently on the top of the stack.
     * This is effectively equivalent to popNode() followed by pushNode(n)
     */
    public void pokeNode(Node n) {
        currentNodeScope.poke(n);
    }

    /** Returns the number of children on the stack in the current node
	 * scope. 
	 */
    public int nodeArity() {
        return currentNodeScope.size();
    }

    public void clearNodeScope() {
        currentNodeScope.clear();
    }

    public void openNodeScope(Node n) {
        new NodeScope();
        if (n!=null) {
            Token next= nextToken(lastConsumedToken);
            n.setBeginLine(next.getBeginLine());
            n.setBeginColumn(next.getBeginColumn());
            n.setInputSource(this.getInputSource());
            n.open();
        }
        if (trace_enabled&&n!=null) LOGGER.info("Opened node scope for node of type: "+n.getClass().getName());
        if (trace_enabled) LOGGER.info("Scope nesting level is "+currentNodeScope.nestingLevel());
    }

    /* A definite node is constructed from a specified number of
	 * children.  That number of nodes are popped from the stack and
	 * made the children of the definite node.  Then the definite node
	 * is pushed on to the stack.
	 */
    public void closeNodeScope(Node n, int num) {
        n.setEndLine(lastConsumedToken.getEndLine());
        n.setEndColumn(lastConsumedToken.getEndColumn());
        if (trace_enabled) LOGGER.info("Closing node scope for node of type: "+n.getClass().getName()+", popping "+num+" nodes off the stack.");
        currentNodeScope.close();
        ArrayList<Node> nodes= new ArrayList<Node> ();
        for (int i= 0; i<num; i++) {
            nodes.add(popNode());
        }
        Collections.reverse(nodes);
        for (Node child : nodes) {
            // FIXME deal with the UNPARSED_TOKENS_ARE_NODES case
            n.addChild(child);
        }
        n.close();
        pushNode(n);
    }

    /**
	 * A conditional node is constructed if the condition is true.  All
	 * the nodes that have been pushed since the node was opened are
	 * made children of the conditional node, which is then pushed
	 * on to the stack.  If the condition is false the node is not
	 * constructed and they are left on the stack. 
	 */
    public void closeNodeScope(Node n, boolean condition) {
        if (n!=null&&condition) {
            n.setEndColumn(lastConsumedToken.getEndColumn());
            n.setEndLine(lastConsumedToken.getEndLine());
            if (trace_enabled) LOGGER.finer("Closing node scope for node of type: "+n.getClass().getName()+", popping "+nodeArity()+" nodes off the stack.");
            int a= nodeArity();
            currentNodeScope.close();
            ArrayList<Node> nodes= new ArrayList<Node> ();
            while (a--> 0) {
                nodes.add(popNode());
            }
            Collections.reverse(nodes);
            for (Node child : nodes) {
                if (unparsedTokensAreNodes&&child instanceof Token) {
                    Token tok= (Token) child;
                    while (tok.getPreviousToken()!=null&&tok.getPreviousToken().isUnparsed()) {
                        tok= tok.getPreviousToken();
                    }
                    while (tok.isUnparsed()) {
                        n.addChild(tok);
                        tok= tok.getNextToken();
                    }
                }
                n.addChild(child);
            }
            n.close();
            if (trace_enabled) {
                LOGGER.info("Closing node scope for node of type: "+n.getClass().getName()+", leaving "+nodeArity()+" nodes on the stack.");
                LOGGER.info("Nesting level is : "+currentNodeScope.nestingLevel());
            }
            pushNode(n);
            if (trace_enabled) {
                LOGGER.info("Closed node scope for node of type: "+n.getClass().getName()+", there are now "+nodeArity()+" nodes on the stack.");
                LOGGER.info("Nesting level is : "+currentNodeScope.nestingLevel());
            }
        }
        else {
            currentNodeScope.close();
            if (trace_enabled&&n!=null) {
                LOGGER.info("Closed node scope for node of type: "+n.getClass().getName()+", leaving "+nodeArity()+" nodes on the stack.");
                LOGGER.info("Nesting level is : "+currentNodeScope.nestingLevel());
            }
        }
    }

    public boolean getBuildTree() {
        return buildTree;
    }

    public void setBuildTree(boolean buildTree) {
        this.buildTree= buildTree;
    }

    /**
     * Just a kludge so that existing jjtree-based code that uses
     * parser.jjtree.foo can work without change.
     */
    JSONCParser jjtree= this;
    @SuppressWarnings("serial")
    class NodeScope extends ArrayList<Node>  {
        NodeScope parentScope;
        NodeScope() {
            this.parentScope= JSONCParser.this.currentNodeScope;
            JSONCParser.this.currentNodeScope= this;
        }

        boolean isRootScope() {
            return parentScope== null;
        }

        Node rootNode() {
            NodeScope ns= this;
            while (ns.parentScope!=null) {
                ns= ns.parentScope;
            }
            return ns.isEmpty()?null:
            ns.get(0);
        }

        Node peek() {
            return isEmpty()?parentScope.peek():
            get(size()-1);
        }

        Node pop() {
            return isEmpty()?parentScope.pop():
            remove(size()-1);
        }

        void poke(Node n) {
            if (isEmpty()) {
                parentScope.poke(n);
            }
            else {
                set(size()-1, n);
            }
        }

        void close() {
            parentScope.addAll(this);
            JSONCParser.this.currentNodeScope= parentScope;
        }

        int nestingLevel() {
            int result= 0;
            NodeScope parent= this;
            while (parent.parentScope!=null) {
                result++;
                parent= parent.parentScope;
            }
            return result;
        }

        public NodeScope clone() {
            NodeScope clone= (NodeScope) super.clone();
            if (parentScope!=null) {
                clone.parentScope= (NodeScope) parentScope.clone();
            }
            return clone;
        }

    }
}
