/* Generated by: JavaCC 21 Parser Generator. JSONCLexer.java */
package org.parsers.jsonc;

import static org.parsers.jsonc.JSONCConstants.TokenType.*;
import java.io.Reader;
import java.io.IOException;
import java.util.logging.Logger;
import java.util.*;
@SuppressWarnings("unused")
public class JSONCLexer implements JSONCConstants {
    private static final Logger LOGGER= Logger.getLogger("JSONCParser");
    private boolean trace_enabled= false;
    public String getInputSource() {
        return inputSource;
    }

    public void setInputSource(String inputSource) {
        this.inputSource= inputSource;
        input_stream.setInputSource(inputSource);
    }

    public JSONCLexer(CharSequence chars) {
        this("input", chars);
    }

    public JSONCLexer(String inputSource, CharSequence chars) {
        this(inputSource, chars, LexicalState.JSON, 1, 1);
    }

    public JSONCLexer(String inputSource, CharSequence chars, LexicalState lexState, int line, int column) {
        this.inputSource= inputSource;
        input_stream= new FileLineMap(inputSource, chars, line, column);
        switchTo(lexState);
    }

    public JSONCLexer(Reader reader) {
        this("input", reader, LexicalState.JSON, 1, 1);
    }

    public JSONCLexer(String inputSource, Reader reader) {
        this(inputSource, reader, LexicalState.JSON, 1, 1);
    }

    public JSONCLexer(String inputSource, Reader reader, LexicalState lexState, int line, int column) {
        this.inputSource= inputSource;
        input_stream= new FileLineMap(inputSource, reader, line, column);
        switchTo(lexState);
    }

    FileLineMap input_stream;
    public final void backup(int amount) {
        input_stream.backup(amount);
    }

    LexicalState lexicalState= LexicalState.JSON;
    /** Switch to specified lexical state. */
    public boolean switchTo(LexicalState lexState) {
        if (this.lexicalState!=lexState) {
            if (trace_enabled) LOGGER.info("Switching from lexical state "+this.lexicalState+" to "+lexState);
            this.lexicalState= lexState;
            return true;
        }
        return false;
    }

    private InvalidToken invalidToken;
    private Token previousToken;
    public Token getNextToken() {
        Token token= null;
        do {
            token= nextToken();
        }
        while (token instanceof InvalidToken);
        if (invalidToken!=null) {
            invalidToken.setNextToken(token);
            token.setPreviousToken(invalidToken);
            Token it= invalidToken;
            this.invalidToken= null;
            it.setUnparsed(true);
            return it;
        }
        token.setPreviousToken(previousToken);
        if (previousToken!=null) previousToken.setNextToken(token);
        return previousToken= token;
    }

    static public String addEscapes(String s) {
        return ParseException.addEscapes(s);
    }

    // Reset the token source input
    // to just after the Token passed in.
    void reset(Token t, LexicalState state) {
        input_stream.goTo(t.getEndLine(), t.getEndColumn());
        input_stream.forward(1);
        t.setNext(null);
        t.setNextToken(null);
        if (state!=null) {
            switchTo(state);
        }
    }

    void reset(Token t) {
        reset(t, null);
    }

    FileLineMap getFileLineMap() {
        return input_stream;
    }

    private int jjnewStateCnt;
    private int jjround;
    private int jjmatchedPos;
    //FIXME,should be an enum.
    private int jjmatchedKind;
    private TokenType matchedType;
    private String inputSource= "input";
    // BitSet for TOKEN
    static private BitSet tokenSet= BitSet.valueOf(new long[]{2170865L, });
    // BitSet for SPECIAL
    static private BitSet specialSet= BitSet.valueOf(new long[]{6L, });
    private final int[] jjrounds= new int[36];
    private final int[] jjstateSet= new int[72];
    private final StringBuilder image= new StringBuilder();
    private int matchedCharsLength;
    char curChar;
    private Token generateEOF() {
        if (trace_enabled) LOGGER.info("Returning the <EOF> token.");
        jjmatchedKind= 0;
        matchedType= TokenType.EOF;
        Token eof= jjFillToken();
        tokenLexicalActions();
        return eof;
    }

    private Token nextToken() {
        Token matchedToken;
        int curPos= 0;
        EOFLoop:
        while (true) {
            curChar= (char) input_stream.beginToken();
            if (curChar== (char)-1) {
                return generateEOF();
            }
            image.setLength(0);
            matchedCharsLength= 0;
            jjmatchedKind= 0x7FFFFFFF;
            matchedType= null;
            jjmatchedPos= 0;
            if (trace_enabled) LOGGER.info("Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") "+"at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
            curPos= jjMoveStringLiteralDfa0_JSON();
            if (jjmatchedKind!=0x7FFFFFFF) {
                if (jjmatchedPos+1<curPos) {
                    if (trace_enabled) LOGGER.info("   Putting back "+(curPos-jjmatchedPos-1)+" characters into the input stream.");
                    input_stream.backup(curPos-jjmatchedPos-1);
                }
                if (trace_enabled) LOGGER.info("****** FOUND A "+tokenImage[jjmatchedKind]+" MATCH ("+addEscapes(input_stream.getSuffix(jjmatchedPos+2))+") ******\n");
                if (tokenSet.get(jjmatchedKind)||specialSet.get(jjmatchedKind)) {
                    matchedToken= jjFillToken();
                    tokenLexicalActions();
                    jjmatchedKind= matchedToken.getType().ordinal();
                    matchedToken.setUnparsed(specialSet.get(jjmatchedKind));
                    return matchedToken;
                }
                else {
                    continue EOFLoop;
                }
            }
            int error_line= input_stream.getEndLine();
            int error_column= input_stream.getEndColumn();
            String error_after= null;
            error_after= curPos<=1?"":
            input_stream.getImage();
            if (invalidToken== null) {
                invalidToken= new InvalidToken(""+curChar, inputSource);
                invalidToken.setBeginLine(error_line);
                invalidToken.setBeginColumn(error_column);
            }
            else {
                invalidToken.setImage(invalidToken.getImage()+curChar);
            }
            invalidToken.setEndLine(error_line);
            invalidToken.setEndColumn(error_column);
            return invalidToken;
        }
    }

    private void tokenLexicalActions() {
        switch(jjmatchedKind) {
        }
    }

    private Token jjFillToken() {
        final Token t;
        final String curTokenImage;
        final int beginLine;
        final int endLine;
        final int beginColumn;
        final int endColumn;
        curTokenImage= input_stream.getImage();
        beginLine= input_stream.getBeginLine();
        beginColumn= input_stream.getBeginColumn();
        endLine= input_stream.getEndLine();
        endColumn= input_stream.getEndColumn();
        t= Token.newToken(TokenType.values()[jjmatchedKind], curTokenImage, this);
        t.setBeginLine(beginLine);
        t.setEndLine(endLine);
        t.setBeginColumn(beginColumn);
        t.setEndColumn(endColumn);
        //        t.setInputSource(this.inputSource);
        return t;
    }

    private void jjCheckNAdd(int state) {
        if (jjrounds[state]!=jjround) {
            jjstateSet[jjnewStateCnt++]= state;
            jjrounds[state]= jjround;
        }
    }

    private void jjAddStates(int start, int end) {
        do {
            jjstateSet[jjnewStateCnt++]= jjnextStates[start];
        }
        while (start++!=end);
    }

    private void jjCheckNAddTwoStates(int state1, int state2) {
        jjCheckNAdd(state1);
        jjCheckNAdd(state2);
    }

    private void jjCheckNAddStates(int start, int end) {
        do {
            jjCheckNAdd(jjnextStates[start]);
        }
        while (start++!=end);
    }

    private void jjCheckNAddStates(int start) {
        jjCheckNAdd(jjnextStates[start]);
        jjCheckNAdd(jjnextStates[start+1]);
    }

    private static boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2) {
        switch(hiByte) {
            case 0:
            return(jjbitVec2[i2]&l2)!=0L;
            default:
            if ((jjbitVec0[i1]&l1)!=0L) {
                return(jjbitVec1[i2]&l2)!=0L;
            }
            return false;
        }
    }

    private int jjStopAtPos(int pos, int kind) {
        jjmatchedKind= kind;
        jjmatchedPos= pos;
        if (trace_enabled) LOGGER.info("   No more string literal token matches are possible.");
        if (trace_enabled) LOGGER.info("   Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token.");
        return pos+1;
    }

    private static final long[] jjbitVec0= {0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL};
    private static final long[] jjbitVec1= {0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL};
    private static final long[] jjbitVec2= {0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL};
    private int jjStartNfa_JSON(int pos, long active0) {
        return jjMoveNfa_JSON(jjStopStringLiteralDfa_JSON(pos, active0), pos+1);
    }

    private final int jjStopStringLiteralDfa_JSON(int pos, long active0) {
        if (trace_enabled) LOGGER.info("   No more string literal token matches are possible.");
        switch(pos) {
            case 0:
            if ((active0&0x20000L)!=0L) {
                jjmatchedKind= 21;
                jjmatchedPos= 0;
                return 36;
            }
            return-1;
            default:
            return-1;
        }
    }

    private int jjMoveStringLiteralDfa0_JSON() {
        switch(curChar) {
            case 44:
            return jjStopAtPos(0, 5);
            case 58:
            return jjStopAtPos(0, 4);
            case 91:
            return jjStopAtPos(0, 6);
            case 93:
            return jjStopAtPos(0, 7);
            case 102:
            return jjMoveStringLiteralDfa1_JSON(0x800L);
            case 110:
            return jjMoveStringLiteralDfa1_JSON(0x1000L);
            case 116:
            return jjMoveStringLiteralDfa1_JSON(0x400L);
            case 123:
            return jjStopAtPos(0, 8);
            case 125:
            return jjStopAtPos(0, 9);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            return jjMoveNfa_JSON(5, 0);
        }
    }

    private int jjMoveStringLiteralDfa1_JSON(long active0) {
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa_JSON(0, active0);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 1;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 97:
            return jjMoveStringLiteralDfa2_JSON(active0, 0x800L);
            case 114:
            return jjMoveStringLiteralDfa2_JSON(active0, 0x400L);
            case 117:
            return jjMoveStringLiteralDfa2_JSON(active0, 0x1000L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa_JSON(0, active0);
    }

    private int jjMoveStringLiteralDfa2_JSON(long old0, long active0) {
        active0= active0&old0;
        if ((active0)== 0L) return jjStartNfa_JSON(0, old0);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa_JSON(1, active0);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 2;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 108:
            return jjMoveStringLiteralDfa3_JSON(active0, 0x1800L);
            case 117:
            return jjMoveStringLiteralDfa3_JSON(active0, 0x400L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa_JSON(1, active0);
    }

    private int jjMoveStringLiteralDfa3_JSON(long old0, long active0) {
        active0= active0&old0;
        if ((active0)== 0L) return jjStartNfa_JSON(1, old0);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa_JSON(2, active0);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 3;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 101:
            if ((active0&0x400L)!=0L) return jjStopAtPos(3, 10);
            break;
            case 108:
            if ((active0&0x1000L)!=0L) return jjStopAtPos(3, 12);
            break;
            case 115:
            return jjMoveStringLiteralDfa4_JSON(active0, 0x800L);
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa_JSON(2, active0);
    }

    private int jjMoveStringLiteralDfa4_JSON(long old0, long active0) {
        active0= active0&old0;
        if ((active0)== 0L) return jjStartNfa_JSON(2, old0);
        int retval= input_stream.readChar();
        if (retval>=0) {
            curChar= (char) retval;
        }
        else {
            jjStopStringLiteralDfa_JSON(3, active0);
            if (trace_enabled&&jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                LOGGER.info("    Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token. ");
            }
            return 4;
        }
        if (trace_enabled) LOGGER.info(""+"Current character : "+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        switch(curChar) {
            case 101:
            if ((active0&0x800L)!=0L) return jjStopAtPos(4, 11);
            break;
            default:
            if (trace_enabled) LOGGER.info("   No string literal matches possible.");
            break;
        }
        return jjStartNfa_JSON(3, active0);
    }

    private int jjMoveNfa_JSON(int startState, int curPos) {
        int startsAt= 0;
        jjnewStateCnt= 36;
        int i= 1;
        jjstateSet[0]= startState;
        int kind= 0x7fffffff;
        while (true) {
            if (++jjround== 0x7fffffff) {
                jjround= 0x80000001;
                Arrays.fill(jjrounds, 0x80000000);
            }
            if (curChar<64) {
                long l= 1L<<curChar;
                do {
                    switch(jjstateSet[--i]) {
                        case 36:
                        case 29:
                        if ((0x400000000000L&l)!=0L) jjCheckNAdd(30);
                        break;
                        case 5:
                        if ((0x3fe000000000000L&l)!=0L) {
                            if (kind> 21) kind= 21;
                            jjAddStates(0, 2);
                        }
                        else if ((0x100002600L&l)!=0L) {
                            if (kind> 3) kind= 3;
                            jjstateSet[jjnewStateCnt++]= 15;
                        }
                        else if ((0x1000000000000L&l)!=0L) {
                            if (kind> 21) kind= 21;
                            jjAddStates(3, 4);
                        }
                        else if ((0x200000000000L&l)!=0L) jjAddStates(5, 6);
                        else if ((0x400000000L&l)!=0L) jjCheckNAddStates(7, 10);
                        else if ((0x800000000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 6;
                        if ((0x800000000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 0;
                        break;
                        case 0:
                        if ((0x800000000000L&l)!=0L) jjCheckNAddStates(11, 13);
                        break;
                        case 1:
                        if ((0xffffffffffffdbffL&l)!=0L) jjAddStates(14, 16);
                        break;
                        case 2:
                        if ((0x400L&l)!=0L&&kind> 1) kind= 1;
                        break;
                        case 3:
                        if ((0x2000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 2;
                        break;
                        case 4:
                        if ((0x2400L&l)!=0L&&kind> 1) kind= 1;
                        break;
                        case 6:
                        if ((0x40000000000L&l)!=0L) jjCheckNAddTwoStates(7, 8);
                        break;
                        case 7:
                        if ((0xfffffbffffffffffL&l)!=0L) jjAddStates(17, 18);
                        break;
                        case 8:
                        if ((0x40000000000L&l)!=0L) jjAddStates(19, 21);
                        break;
                        case 9:
                        case 13:
                        if ((0x40000000000L&l)!=0L) jjAddStates(22, 24);
                        break;
                        case 10:
                        if ((0x800000000000L&l)!=0L&&kind> 2) kind= 2;
                        break;
                        case 11:
                        if ((0xffff7bffffffffffL&l)!=0L) jjCheckNAddTwoStates(12, 13);
                        break;
                        case 12:
                        if ((0xfffffbffffffffffL&l)!=0L) jjCheckNAddTwoStates(13, 12);
                        break;
                        case 14:
                        if ((0x800000000000L&l)!=0L) jjCheckNAdd(6);
                        break;
                        case 15:
                        if ((0x100002600L&l)== 0L) break;
                        if (kind> 3) kind= 3;
                        jjCheckNAdd(15);
                        break;
                        case 16:
                        if ((0x400000000L&l)!=0L) jjCheckNAddStates(7, 10);
                        break;
                        case 17:
                        if ((0xfffffffb00000000L&l)!=0L) jjAddStates(25, 28);
                        break;
                        case 18:
                        if ((0x400000000L&l)!=0L&&kind> 16) kind= 16;
                        break;
                        case 20:
                        if ((0x3ff000000000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 21;
                        break;
                        case 21:
                        if ((0x3ff000000000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 22;
                        break;
                        case 22:
                        if ((0x3ff000000000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 23;
                        break;
                        case 23:
                        if ((0x3ff000000000000L&l)!=0L) jjCheckNAddStates(25, 28);
                        break;
                        case 26:
                        if ((0x800400000000L&l)!=0L) jjCheckNAddStates(25, 28);
                        break;
                        case 27:
                        if ((0x200000000000L&l)!=0L) jjCheckNAddTwoStates(28, 34);
                        break;
                        case 28:
                        if ((0x1000000000000L&l)== 0L) break;
                        if (kind> 21) kind= 21;
                        jjCheckNAddTwoStates(29, 31);
                        break;
                        case 30:
                        if ((0x3ff000000000000L&l)== 0L) break;
                        if (kind> 21) kind= 21;
                        jjAddStates(29, 30);
                        break;
                        case 32:
                        if ((0x280000000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 33;
                        break;
                        case 33:
                        if ((0x3fe000000000000L&l)== 0L) break;
                        if (kind> 21) kind= 21;
                        jjstateSet[jjnewStateCnt++]= 33;
                        break;
                        case 34:
                        if ((0x3fe000000000000L&l)== 0L) break;
                        if (kind> 21) kind= 21;
                        jjCheckNAddStates(0, 2);
                        break;
                        case 35:
                        if ((0x3ff000000000000L&l)== 0L) break;
                        if (kind> 21) kind= 21;
                        jjAddStates(31, 33);
                        break;
                        default:
                        break;
                    }
                }
                while (i!=startsAt);
            }
            else if (curChar<128) {
                long l= 1L<<(curChar&077);
                do {
                    switch(jjstateSet[--i]) {
                        case 36:
                        case 31:
                        if ((0x2000000020L&l)!=0L) jjCheckNAdd(32);
                        break;
                        case 1:
                        jjAddStates(14, 16);
                        break;
                        case 7:
                        jjAddStates(17, 18);
                        break;
                        case 11:
                        jjCheckNAddTwoStates(12, 13);
                        break;
                        case 12:
                        jjCheckNAddTwoStates(13, 12);
                        break;
                        case 17:
                        if ((0xffffffffefffffffL&l)!=0L) jjAddStates(25, 28);
                        break;
                        case 19:
                        if ((0x20000000000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 20;
                        break;
                        case 20:
                        if ((0x7e0000007eL&l)!=0L) jjstateSet[jjnewStateCnt++]= 21;
                        break;
                        case 21:
                        if ((0x7e0000007eL&l)!=0L) jjstateSet[jjnewStateCnt++]= 22;
                        break;
                        case 22:
                        if ((0x7e0000007eL&l)!=0L) jjstateSet[jjnewStateCnt++]= 23;
                        break;
                        case 23:
                        if ((0x7e0000007eL&l)!=0L) jjCheckNAddStates(25, 28);
                        break;
                        case 24:
                        if ((0x10000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 19;
                        break;
                        case 25:
                        if ((0x10000000L&l)!=0L) jjstateSet[jjnewStateCnt++]= 26;
                        break;
                        case 26:
                        if ((0x14404410000000L&l)!=0L) jjCheckNAddStates(25, 28);
                        break;
                        default:
                        break;
                    }
                }
                while (i!=startsAt);
            }
            else {
                int hiByte= (int)(curChar>>8);
                int i1= hiByte>>6;
                long l1= 1L<<(hiByte&077);
                int i2= (curChar&0xff)>>6;
                long l2= 1L<<(curChar&077);
                do {
                    switch(jjstateSet[--i]) {
                        case 1:
                        if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(14, 16);
                        break;
                        case 7:
                        if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(17, 18);
                        break;
                        case 11:
                        if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(12, 13);
                        break;
                        case 12:
                        if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjCheckNAddTwoStates(13, 12);
                        break;
                        case 17:
                        if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(25, 28);
                        break;
                        default:
                        break;
                    }
                }
                while (i!=startsAt);
            }
            if (kind!=0x7fffffff) {
                jjmatchedKind= kind;
                jjmatchedPos= curPos;
                kind= 0x7fffffff;
            }
            ++curPos;
            if (jjmatchedKind!=0&&jjmatchedKind!=0x7fffffff) {
                if (trace_enabled) LOGGER.info("   Currently matched the first "+(jjmatchedPos+1)+" characters as a "+tokenImage[jjmatchedKind]+" token.");
            }
            if ((i= jjnewStateCnt)== (startsAt= 36-(jjnewStateCnt= startsAt))) return curPos;
            int retval= input_stream.readChar();
            if (retval>=0) {
                curChar= (char) retval;
            }
            else {
                return curPos;
            }
            if (trace_enabled) LOGGER.info(""+addEscapes(String.valueOf(curChar))+" ("+(int) curChar+") "+"at line "+input_stream.getEndLine()+" column "+input_stream.getEndColumn());
        }
    }

    private static final int[] jjnextStates= {35, 29, 31, 29, 31, 28, 34, 17, 24, 25, 18, 1, 3, 4, 3, 4, 1, 8, 7, 9, 11, 10, 10, 9, 11, 18, 17, 24, 25, 30, 31, 29, 31, 35};
}
