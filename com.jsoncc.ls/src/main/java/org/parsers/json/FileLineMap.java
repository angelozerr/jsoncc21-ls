/* Generated by: JavaCC 21 Parser Generator. FileLineMap.java */
package org.parsers.json;

import java.io.IOException;
import java.io.Reader;
import java.util.HashMap;
import java.util.Map;
import java.util.BitSet;
import java.nio.charset.Charset;
/**
 * Rather bloody-minded implementation of a class to read in a file 
 * and store the contents in a String, and keep track of where the 
 * lines are.
 */
@SuppressWarnings("unused")
public class FileLineMap {
    private static final int[] EMPTY_INT= new int[0];
    static private Map<String, FileLineMap> mapsByName= new HashMap<> ();
    /**
     * Get a FileLineMap by name
     */
    static public FileLineMap getFileLineMapByName(String name) {
        return mapsByName.get(name);
    }

    /**
     * There is something of a memory retention problem
     * with this static lookup map, so this method
     * allows you to just clear the map, assuming you
     * know that none of the entries are needed any more.
     *
    static public void clearFileLineMapCache() {
        mapsByName.clear();
    }

    /**
     * A method to uncache a FileLineMap. There is something of a 
     * memory retention problem, so if you know for sure that 
     * the referenced FileLineMap is not needed, you can use 
     * this method to allow it to be garbage collected.
     */
    static public FileLineMap clearFileLineMapCacheEntry(String inputSource) {
        return mapsByName.remove(inputSource);
    }

    // Munged content, possibly replace unicode escapes, tabs, or CRLF with LF.
    private final CharSequence content;
    // Typically a filename, I suppose.
    private String inputSource;
    // A list of offsets of the beginning of lines
    private final int[] lineOffsets;
    private int startingLine, startingColumn;
    private int bufferPosition, tokenBeginOffset, tokenBeginColumn, tokenBeginLine, line, column;
    // If this is set, it determines 
    // which lines in the file are actually processed.
    private BitSet parsedLines;
    /**
     * @return true if we actually actually parse this line.
     * (Or really whether we lex it, since what happens here is pre-lexical!)
     */
    private boolean isParsedLine(int lineNumber) {
        return parsedLines== null||parsedLines.get(1+lineNumber-startingLine);
    }

    /**
     * This is used in conjunction with having a preprocessor.
     * We set which lines are actually parsed lines and the 
     * unset ones are ignored.
     */
    public void setParsedLines(BitSet parsedLines) {
        this.parsedLines= parsedLines;
    }

    public FileLineMap(String inputSource, Reader reader, int startingLine, int startingColumn) {
        this(inputSource, readToEnd(reader), startingLine, startingColumn);
    }

    public FileLineMap(String inputSource, CharSequence content) {
        this(inputSource, content, 1, 1);
    }

    public FileLineMap(String inputSource, CharSequence content, int startingLine, int startingColumn) {
        setInputSource(inputSource);
        this.content= mungeContent(content, 0, true, false, false);
        this.lineOffsets= createLineOffsetsTable(this.content);
        this.setStartPosition(startingLine, startingColumn);
    }

    // START API methods
    // Now some methods to fulfill the functionality that used to be in that
    // SimpleCharStream class
    // This backup() method is dead simple by design and does not handle any of the messiness
    // with column numbers relating to tabs or unicode escapes. 
    public void backup(int amount) {
        for (int i= 0; i<amount; i++) {
            if (column== 1) {
                backupLine();
            }
            else {
                --column;
                --bufferPosition;
            }
        }
    }

    void forward(int amount) {
        for (int i= 0; i<amount; i++) {
            if (column<getLineLength(line)) {
                ++bufferPosition;
                ++column;
            }
            else {
                advanceLine();
            }
        }
    }

    private void advanceLine() {
        do {
            ++line;
        }
        while (!isParsedLine(line)&&line-startingLine<lineOffsets.length);
        if (line-startingLine>=lineOffsets.length) {
            bufferPosition= content.length();
        }
        else {
            bufferPosition= getLineStartOffset(line);
        }
        column= 1;
    }

    private void backupLine() {
        do {
            --line;
        }
        while (!isParsedLine(line)&&line>=startingLine);
        if (line<startingLine) {
            goTo(startingLine, startingColumn);
        }
        else {
            column= getLineLength(line);
            bufferPosition= getLineStartOffset(line)+column-1;
        }
    }

    int readChar() {
        if (bufferPosition>=content.length()) {
            return-1;
        }
        int ch= content.charAt(bufferPosition++);
        if (ch== '\n') {
            advanceLine();
            column= 1;
        }
        else {
            ++column;
        }
        return ch;
    }

    String getImage() {
        CharSequence image= content.subSequence(tokenBeginOffset, bufferPosition);
        if (tokenBeginLine== this.line||parsedLines== null) {
            // If it is all on one line, or we don't have any 
            // line marker bitset, then there is nothing more to do.
            return image.toString();
        }
        boolean hasUnparsedLines= false;
        for (int i= tokenBeginLine; i<=line; i++) {
            if (!isParsedLine(i)) {
                hasUnparsedLines= true;
                break;
            }
        }
        if (!hasUnparsedLines) {
            // We're okay here too.
            return image.toString();
        }
        return onlyRelevantPart(image, tokenBeginLine);
    }

    /**
     * @return only the part of the input that is not actually not
     * turned off by the preprocesor.
     */
    private String onlyRelevantPart(CharSequence input, int currentLine) {
        StringBuilder buf= new StringBuilder();
        boolean on= isParsedLine(currentLine);
        for (int i= 0; i<input.length(); i++) {
            char ch= input.charAt(i);
            if (on) buf.append(ch);
            if (ch== '\n') {
                on= isParsedLine(++currentLine);
            }
        }
        return buf.toString();
    }

    String getSuffix(final int len) {
        int startPos= bufferPosition-len+1;
        return content.subSequence(startPos, bufferPosition).toString();
    }

    int beginToken() {
        if (!isParsedLine(line)) {
            advanceLine();
        }
        tokenBeginOffset= bufferPosition;
        tokenBeginColumn= column;
        tokenBeginLine= line;
        return readChar();
    }

    int getBeginColumn() {
        return tokenBeginColumn;
    }

    int getBeginLine() {
        return tokenBeginLine;
    }

    int getEndColumn() {
        if (column== 1) {
            if (line== tokenBeginLine) {
                return 1;
            }
            return getLineLength(line-1);
        }
        return column-1;
    }

    int getEndLine() {
        if (column== 1&&line> tokenBeginLine) return line-1;
        return line;
    }

    // But there is no goto in Java!!!
    void goTo(int line, int column) {
        this.bufferPosition= getOffset(line, column);
        this.line= line;
        this.column= column;
    }

    // END API methods
    private int getLineLength(int lineNumber) {
        int startOffset= getLineStartOffset(lineNumber);
        int endOffset= getLineEndOffset(lineNumber);
        return 1+endOffset-startOffset;
    }

    private int getLineStartOffset(int lineNumber) {
        int realLineNumber= lineNumber-startingLine;
        if (realLineNumber<=0) {
            return 0;
        }
        if (realLineNumber>=lineOffsets.length) {
            return content.length();
        }
        return lineOffsets[realLineNumber];
    }

    private int getLineEndOffset(int lineNumber) {
        int realLineNumber= lineNumber-startingLine;
        if (realLineNumber<0) {
            return 0;
        }
        if (realLineNumber>=lineOffsets.length) {
            return content.length();
        }
        if (realLineNumber== lineOffsets.length-1) {
            return content.length()-1;
        }
        return lineOffsets[realLineNumber+1]-1;
    }

    private void setStartPosition(int line, int column) {
        this.startingLine= line;
        this.startingColumn= column;
        this.line= line;
        this.column= column;
    }

    private int getOffset(int line, int column) {
        if (line== 0) line= startingLine;
        // REVISIT? This should not be necessary!
        int columnAdjustment= (line== startingLine)?startingColumn:
        1;
        return lineOffsets[line-startingLine]+column-columnAdjustment;
    }

    // ------------- private utilities method
    // Icky method to handle annoying stuff. Might make this public later if it is
    // needed elsewhere
    private static CharSequence mungeContent(CharSequence content, int tabsToSpaces, boolean preserveLines, boolean javaUnicodeEscape, boolean ensureFinalEndline) {
        if (tabsToSpaces<=0&&preserveLines&&!javaUnicodeEscape) {
            if (ensureFinalEndline) {
                char lastChar= content.charAt(content.length()-1);
                if (lastChar!='\n'&&lastChar!='\r') {
                    if (content instanceof StringBuilder) {
                        ((StringBuilder) content).append((char)'\n');
                    }
                    else {
                        StringBuilder buf= new StringBuilder(content.length()+1);
                        buf.append(content);
                        buf.append((char)'\n');
                        content= buf;
                    }
                }
            }
            return content;
        }
        StringBuilder buf= new StringBuilder();
        int index= 0;
        int col= 0;
        // This is just to handle tabs to spaces. If you don't have that setting set, it
        // is really unused.
        while (index<content.length()) {
            char ch= content.charAt(index++);
            if (ch== '\\'&&javaUnicodeEscape&&index<content.length()) {
                ch= content.charAt(index++);
                if (ch!='u') {
                    buf.append((char)'\\');
                    buf.append(ch);
                    if (ch== '\n') col= 0;
                    else col+=2;
                }
                else {
                    while (content.charAt(index)== 'u') {
                        index++;
                        // col++;
                    }
                    String hex= content.subSequence(index, index+=4).toString();
                    buf.append((char) Integer.parseInt(hex, 16));
                    // col +=6;
                    ++col;
                    // We're not going to be trying to track line/column information relative to the original content
                    // with tabs or unicode escape, so we just increment 1, not 6
                }
            }
            else if (ch== '\r'&&!preserveLines) {
                buf.append((char)'\n');
                if (index<content.length()) {
                    ch= content.charAt(index++);
                    if (ch!='\n') {
                        buf.append(ch);
                        ++col;
                    }
                    else col= 0;
                }
            }
            else if (ch== '\t'&&tabsToSpaces> 0) {
                int spacesToAdd= tabsToSpaces-col%tabsToSpaces;
                for (int i= 0; i<spacesToAdd; i++) {
                    buf.append((char)' ');
                    col++;
                }
            }
            else {
                buf.append((char) ch);
                if (ch== '\n') {
                    col= 0;
                }
                else col++;
            }
        }
        if (ensureFinalEndline) {
            char lastChar= buf.charAt(buf.length()-1);
            if (lastChar!='\n'&&lastChar!='\r') buf.append((char)'\n');
        }
        return buf.toString();
    }

    private static int[] createLineOffsetsTable(CharSequence content) {
        if (content.length()== 0) {
            return EMPTY_INT;
        }
        int lineCount= 0;
        char ch;
        int length= content.length();
        for (int i= 0; i<length; i++) {
            ch= content.charAt(i);
            if (ch== '\n') {
                lineCount++;
            }
        }
        if (content.charAt(length-1)!='\n') {
            lineCount++;
        }
        int[] lineOffsets= new int[lineCount];
        lineOffsets[0]= 0;
        int index= 1;
        for (int i= 0; i<length; i++) {
            ch= content.charAt(i);
            if (ch== '\n') {
                if (i+1== length) break;
                lineOffsets[index++]= i+1;
            }
        }
        return lineOffsets;
    }

    public String getInputSource() {
        return inputSource;
    }

    void setInputSource(String inputSource) {
        mapsByName.put(inputSource, this);
        this.inputSource= inputSource;
    }

    String getText(int beginLine, int beginColumn, int endLine, int endColumn) {
        int startOffset= getOffset(beginLine, beginColumn);
        int endOffset= getOffset(endLine, endColumn);
        return getText(startOffset, endOffset);
    }

    private String getText(int startOffset, int endOffset) {
        return content.subSequence(startOffset, endOffset+1).toString();
    }

    static private int BUF_SIZE= 0x10000;
    // Annoying kludge really...
    static String readToEnd(Reader reader) {
        try {
            return readFully(reader);
        }
        catch(IOException ioe) {
            throw new RuntimeException(ioe);
        }
    }

    static String readFully(Reader reader) throws IOException {
        char[] block= new char[BUF_SIZE];
        int charsRead= reader.read(block);
        if (charsRead<0) {
            throw new IOException("No input");
        }
        else if (charsRead<BUF_SIZE) {
            char[] result= new char[charsRead];
            System.arraycopy(block, 0, result, 0, charsRead);
            reader.close();
            return new String(block, 0, charsRead);
        }
        StringBuilder buf= new StringBuilder();
        buf.append(block);
        do {
            charsRead= reader.read(block);
            if (charsRead> 0) {
                buf.append(block, 0, charsRead);
            }
        }
        while (charsRead== BUF_SIZE);
        reader.close();
        return buf.toString();
    }

    /**
     * Rather bloody-minded way of converting a byte array into a string
     * taking into account the initial byte order mark (used by Microsoft a lot seemingly)
     * See: https://docs.microsoft.com/es-es/globalization/encoding/byte-order-markc
     */
    static public String stringFromBytes(byte[] bytes) {
        int arrayLength= bytes.length;
        int firstByte= arrayLength> 0?Byte.toUnsignedInt(bytes[0]):
        1;
        int secondByte= arrayLength> 1?Byte.toUnsignedInt(bytes[1]):
        1;
        int thirdByte= arrayLength> 2?Byte.toUnsignedInt(bytes[2]):
        1;
        int fourthByte= arrayLength> 3?Byte.toUnsignedInt(bytes[3]):
        1;
        if (firstByte== 0xEF&&secondByte== 0xBB&&thirdByte== 0xBF) {
            return new String(bytes, 3, bytes.length-3, Charset.forName("UTF-8"));
        }
        if (firstByte== 0&&secondByte== 0&&thirdByte== 0xFE&&fourthByte== 0xFF) {
            return new String(bytes, 4, bytes.length-4, Charset.forName("UTF-32BE"));
        }
        if (firstByte== 0xFF&&secondByte== 0xFE&&thirdByte== 0&&fourthByte== 0) {
            return new String(bytes, 4, bytes.length-4, Charset.forName("UTF-32LE"));
        }
        if (firstByte== 0xFE&&secondByte== 0xFF) {
            return new String(bytes, 2, bytes.length-2, Charset.forName("UTF-16BE"));
        }
        if (firstByte== 0xFF&&secondByte== 0xFE) {
            return new String(bytes, 2, bytes.length-2, Charset.forName("UTF-16LE"));
        }
        return new String(bytes, Charset.forName("UTF-8"));
    }

}
