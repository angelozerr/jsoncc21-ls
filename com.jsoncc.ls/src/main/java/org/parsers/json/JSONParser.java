/* Generated by: JavaCC 21 Parser Generator. JSONParser.java */
package org.parsers.json;

import org.parsers.json.ast.*;
import java.util.*;
import java.util.concurrent.CancellationException;
import java.util.logging.*;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import static org.parsers.json.JSONConstants.TokenType.*;
@SuppressWarnings("unused")
public class JSONParser implements JSONConstants {
    private static final java.util.logging.Logger LOGGER= Logger.getLogger(JSONParser.class.getName());
    public static void setLogLevel(Level level) {
        LOGGER.setLevel(level);
        Logger.getGlobal().getParent().getHandlers()[0].setLevel(level);
    }

    static final int UNLIMITED= Integer.MAX_VALUE;
    // The last token successfully "consumed"     
    Token lastConsumedToken= new Token();
    // We start with a dummy token. REVISIT
    private TokenType nextTokenType;
    private Token currentLookaheadToken;
    private int remainingLookahead;
    private boolean scanToEnd, hitFailure, lastLookaheadSucceeded;
    private String currentlyParsedProduction, currentLookaheadProduction;
    private int lookaheadRoutineNesting;
    private EnumSet<TokenType> outerFollowSet;
    private boolean cancelled;
    public void cancel() {
        cancelled= true;
    }

    public boolean isCancelled() {
        return cancelled;
    }

    /** Generated Lexer. */
    public JSONLexer token_source;
    public void setInputSource(String inputSource) {
        token_source.setInputSource(inputSource);
    }

    String getInputSource() {
        return token_source.getInputSource();
    }

    //=================================
    // Generated constructors
    //=================================
    public JSONParser(String inputSource, CharSequence content) {
        this(new JSONLexer(inputSource, content));
    }

    public JSONParser(CharSequence content) {
        this("input", content);
    }

    public JSONParser(String inputSource, Path path) throws IOException {
        this(inputSource, FileLineMap.stringFromBytes(Files.readAllBytes(path)));
    }

    public JSONParser(Path path) throws IOException {
        this(path.toString(), path);
    }

    public JSONParser(java.io.InputStream stream) {
        this(new InputStreamReader(stream));
    }

    public JSONParser(Reader reader) {
        this(new JSONLexer("input", reader));
    }

    /** Constructor with user supplied Lexer. */
    public JSONParser(JSONLexer lexer) {
        token_source= lexer;
        lastConsumedToken.setInputSource(lexer.getInputSource());
    }

    // If tok already has a next field set, it returns that
    // Otherwise, it goes to the token_source, i.e. the Lexer.
    final private Token nextToken(final Token tok) {
        Token result= tok== null?null:
        tok.getNext();
        Token previous= null;
        while (result== null) {
            nextTokenType= null;
            Token next= token_source.getNextToken();
            previous= next;
            if (!next.isUnparsed()) {
                result= next;
            }
            else if (next instanceof InvalidToken) {
                result= next.getNextToken();
            }
        }
        if (tok!=null) tok.setNext(result);
        nextTokenType= null;
        return result;
    }

    final public Token getNextToken() {
        return getToken(1);
    }

    /** Get the specific Token index ahead in the stream. */
    final public Token getToken(int index) {
        Token t= currentLookaheadToken== null?lastConsumedToken:
        currentLookaheadToken;
        for (int i= 0; i<index; i++) {
            t= nextToken(t);
        }
        return t;
    }

    private final TokenType nextTokenType() {
        if (nextTokenType== null) {
            nextTokenType= nextToken(lastConsumedToken).getType();
        }
        return nextTokenType;
    }

    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:65:1
    final public void Array() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 65 of C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc");
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Array";
        Array Array1= null;
        if (buildTree) {
            Array1= new Array();
            Array1.setInputSource(getInputSource());
            openNodeScope(Array1);
        }
        ParseException parseException1= null;
        int callStackSize2= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:66:5
            consumeToken(OPEN_BRACKET);
            // Code for ZeroOrOne specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:67:5
            if (first_set$JSON_javacc$68$7.contains(nextTokenType())) {
                // Code for NonTerminal specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:7
                pushOntoCallStack("Array", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 68, 7);
                outerFollowSet= follow_set$JSON_javacc$68$7$;
                try {
                    Value();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrMore specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:14
                while (true) {
                    if (!(nextTokenType()== COMMA)) break;
                    // Code for RegexpRef specified at:
                    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:15
                    consumeToken(COMMA);
                    // Code for NonTerminal specified at:
                    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:23
                    pushOntoCallStack("Array", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 68, 23);
                    outerFollowSet= follow_set$JSON_javacc$68$23;
                    try {
                        Value();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
            // Code for RegexpRef specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:70:5
            consumeToken(CLOSE_BRACKET);
        }
        catch(ParseException e) {
            parseException1= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2);
            if (buildTree) {
                if (parseException1== null) {
                    closeNodeScope(Array1, nodeArity()> 1);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException1.getMessage());
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> Value_FIRST_SET= EnumSet.of(OPEN_BRACKET, OPEN_BRACE, TRUE, FALSE, NULL, STRING_LITERAL, NUMBER);
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:73:1
    final public void Value() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 73 of C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc");
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Value";
        // Code for ExpansionChoice specified at:
        // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:74:5
        Value Value2= null;
        if (buildTree) {
            Value2= new Value();
            Value2.setInputSource(getInputSource());
            openNodeScope(Value2);
        }
        ParseException parseException31= null;
        int callStackSize32= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            if (nextTokenType()== TRUE) {
                // Code for RegexpRef specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:74:5
                consumeToken(TRUE);
            }
            else if (nextTokenType()== FALSE) {
                // Code for RegexpRef specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:76:5
                consumeToken(FALSE);
            }
            else if (nextTokenType()== NULL) {
                // Code for RegexpRef specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:78:5
                consumeToken(NULL);
            }
            else if (nextTokenType()== STRING_LITERAL) {
                // Code for RegexpRef specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:80:5
                consumeToken(STRING_LITERAL);
            }
            else if (nextTokenType()== NUMBER) {
                // Code for RegexpRef specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:82:5
                consumeToken(NUMBER);
            }
            else if (nextTokenType()== OPEN_BRACKET) {
                // Code for NonTerminal specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:84:5
                pushOntoCallStack("Value", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 84, 5);
                try {
                    Array();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== OPEN_BRACE) {
                // Code for NonTerminal specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:86:5
                pushOntoCallStack("Value", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 86, 5);
                try {
                    JSONObject();
                }
                finally {
                    popCallStack();
                }
            }
            else {
                pushOntoCallStack("Value", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 74, 5);
                throw new ParseException(this, Value_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException31= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize32);
            if (buildTree) {
                if (parseException31== null) {
                    closeNodeScope(Value2, nodeArity()> 1);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException31.getMessage());
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:1
    final public void KeyValuePair() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 89 of C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc");
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "KeyValuePair";
        KeyValuePair KeyValuePair3= null;
        if (buildTree) {
            KeyValuePair3= new KeyValuePair();
            KeyValuePair3.setInputSource(getInputSource());
            openNodeScope(KeyValuePair3);
        }
        ParseException parseException76= null;
        int callStackSize77= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:16
            consumeToken(STRING_LITERAL);
            // Code for RegexpRef specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:33
            consumeToken(COLON);
            // Code for NonTerminal specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:41
            pushOntoCallStack("KeyValuePair", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 89, 41);
            try {
                Value();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException76= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize77);
            if (buildTree) {
                if (parseException76== null) {
                    closeNodeScope(KeyValuePair3, nodeArity()> 1);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException76.getMessage());
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:91:1
    final public void JSONObject() throws ParseException {
        if (trace_enabled) LOGGER.info("Entering production defined on line 91 of C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc");
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "JSONObject";
        JSONObject JSONObject4= null;
        if (buildTree) {
            JSONObject4= new JSONObject();
            JSONObject4.setInputSource(getInputSource());
            openNodeScope(JSONObject4);
        }
        ParseException parseException88= null;
        int callStackSize89= parsingStack.size();
        try {
            if (false) throw new ParseException("Never happens!");
            // Code for RegexpRef specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:92:5
            consumeToken(OPEN_BRACE);
            // Code for ZeroOrOne specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:93:5
            if (nextTokenType()== STRING_LITERAL) {
                // Code for NonTerminal specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:9
                pushOntoCallStack("JSONObject", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 94, 9);
                outerFollowSet= follow_set$JSON_javacc$94$9;
                try {
                    KeyValuePair();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrMore specified at:
                // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:22
                while (true) {
                    if (!(nextTokenType()== COMMA)) break;
                    // Code for RegexpStringLiteral specified at:
                    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:23
                    consumeToken(COMMA);
                    // Code for NonTerminal specified at:
                    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:27
                    pushOntoCallStack("JSONObject", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 94, 27);
                    outerFollowSet= follow_set$JSON_javacc$94$27;
                    try {
                        KeyValuePair();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
            // Code for RegexpRef specified at:
            // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:96:5
            consumeToken(CLOSE_BRACE);
        }
        catch(ParseException e) {
            parseException88= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize89);
            if (buildTree) {
                if (parseException88== null) {
                    closeNodeScope(JSONObject4, nodeArity()> 1);
                }
                else {
                    if (trace_enabled) LOGGER.warning("ParseException: "+parseException88.getMessage());
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> first_set$JSON_javacc$68$7= EnumSet.of(OPEN_BRACKET, OPEN_BRACE, TRUE, FALSE, NULL, STRING_LITERAL, NUMBER);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$68$7$= EnumSet.of(COMMA, CLOSE_BRACKET);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$68$23= EnumSet.of(CLOSE_BRACKET);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$94$9= EnumSet.of(COMMA, CLOSE_BRACE);
    static private final EnumSet<TokenType> follow_set$JSON_javacc$94$27= EnumSet.of(CLOSE_BRACE);
    private final boolean scanToken(TokenType expectedType) {
        currentLookaheadToken= nextToken(currentLookaheadToken);
        TokenType type= currentLookaheadToken.getType();
        if (type!=expectedType) return lastLookaheadSucceeded= false;
        if (remainingLookahead!=UNLIMITED) remainingLookahead--;
        return lastLookaheadSucceeded= true;
    }

    private final boolean scanToken(EnumSet<TokenType> types) {
        currentLookaheadToken= nextToken(currentLookaheadToken);
        TokenType type= currentLookaheadToken.getType();
        if (!types.contains(type)) return lastLookaheadSucceeded= false;
        if (remainingLookahead!=UNLIMITED) remainingLookahead--;
        //     if (type == upToTokenType) remainingLookahead = 0;
        return lastLookaheadSucceeded= true;
    }

    //====================================
    // Lookahead Routines
    //====================================
    // scanahead routine for expansion at: 
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:7
    // BuildScanRoutine macro
    private final boolean check$JSON_javacc$68$7() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:7
            pushOntoLookaheadStack("Array", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 68, 7);
            String prevProduction118= currentLookaheadProduction;
            currentLookaheadProduction= "Value";
            scanToEnd= false;
            try {
                if (!check$Value()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction118;
            }
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for ZeroOrMore specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:14
            while (remainingLookahead> 0&&!hitFailure) {
                Token token119= currentLookaheadToken;
                if (!check$JSON_javacc$68$15()) {
                    currentLookaheadToken= token119;
                    break;
                }
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:15
    // BuildScanRoutine macro
    private final boolean check$JSON_javacc$68$15() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:15
            if (!scanToken(COMMA)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:68:23
            pushOntoLookaheadStack("Array", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 68, 23);
            String prevProduction120= currentLookaheadProduction;
            currentLookaheadProduction= "Value";
            scanToEnd= true;
            try {
                if (!check$Value()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction120;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:84:5
    // BuildScanRoutine macro
    private final boolean check$JSON_javacc$84$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:84:5
            pushOntoLookaheadStack("Value", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 84, 5);
            String prevProduction121= currentLookaheadProduction;
            currentLookaheadProduction= "Array";
            scanToEnd= false;
            try {
                if (!check$Array()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction121;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:86:5
    // BuildScanRoutine macro
    private final boolean check$JSON_javacc$86$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:86:5
            pushOntoLookaheadStack("Value", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 86, 5);
            String prevProduction122= currentLookaheadProduction;
            currentLookaheadProduction= "JSONObject";
            scanToEnd= false;
            try {
                if (!check$JSONObject()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction122;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:9
    // BuildScanRoutine macro
    private final boolean check$JSON_javacc$94$9() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:9
            pushOntoLookaheadStack("JSONObject", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 94, 9);
            String prevProduction123= currentLookaheadProduction;
            currentLookaheadProduction= "KeyValuePair";
            scanToEnd= false;
            try {
                if (!check$KeyValuePair()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction123;
            }
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for ZeroOrMore specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:22
            while (remainingLookahead> 0&&!hitFailure) {
                Token token124= currentLookaheadToken;
                if (!check$JSON_javacc$94$23()) {
                    currentLookaheadToken= token124;
                    break;
                }
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:23
    // BuildScanRoutine macro
    private final boolean check$JSON_javacc$94$23() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:23
            if (!scanToken(COMMA)) return lastLookaheadSucceeded= false;
            if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
            // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:94:27
            pushOntoLookaheadStack("JSONObject", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 94, 27);
            String prevProduction125= currentLookaheadProduction;
            currentLookaheadProduction= "KeyValuePair";
            scanToEnd= true;
            try {
                if (!check$KeyValuePair()) return lastLookaheadSucceeded= false;
            }
            finally {
                popLookaheadStack();
                currentLookaheadProduction= prevProduction125;
            }
            return lastLookaheadSucceeded= true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Array() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:66:5
        if (!scanToken(OPEN_BRACKET)) return lastLookaheadSucceeded= false;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ZeroOrOne specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:67:5
        Token token126= currentLookaheadToken;
        if (!check$JSON_javacc$68$7()) currentLookaheadToken= token126;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:70:5
        if (!scanToken(CLOSE_BRACKET)) return lastLookaheadSucceeded= false;
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Value() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ExpansionChoice specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:74:5
        Token token127= currentLookaheadToken;
        int remainingLookahead127= remainingLookahead;
        boolean hitFailure127= hitFailure;
        if (!scanToken(TRUE)) {
            currentLookaheadToken= token127;
            remainingLookahead= remainingLookahead127;
            hitFailure= hitFailure127;
            if (!scanToken(FALSE)) {
                currentLookaheadToken= token127;
                remainingLookahead= remainingLookahead127;
                hitFailure= hitFailure127;
                if (!scanToken(NULL)) {
                    currentLookaheadToken= token127;
                    remainingLookahead= remainingLookahead127;
                    hitFailure= hitFailure127;
                    if (!scanToken(STRING_LITERAL)) {
                        currentLookaheadToken= token127;
                        remainingLookahead= remainingLookahead127;
                        hitFailure= hitFailure127;
                        if (!scanToken(NUMBER)) {
                            currentLookaheadToken= token127;
                            remainingLookahead= remainingLookahead127;
                            hitFailure= hitFailure127;
                            if (!check$JSON_javacc$84$5()) {
                                currentLookaheadToken= token127;
                                remainingLookahead= remainingLookahead127;
                                hitFailure= hitFailure127;
                                if (!check$JSON_javacc$86$5()) {
                                    currentLookaheadToken= token127;
                                    remainingLookahead= remainingLookahead127;
                                    hitFailure= hitFailure127;
                                    return lastLookaheadSucceeded= false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$KeyValuePair() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:16
        if (!scanToken(STRING_LITERAL)) return lastLookaheadSucceeded= false;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:33
        if (!scanToken(COLON)) return lastLookaheadSucceeded= false;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for NonTerminal specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:89:41
        pushOntoLookaheadStack("KeyValuePair", "C:\\Users\\azerr\\git\\javacc21\\examples\\json\\JSON.javacc", 89, 41);
        String prevProduction128= currentLookaheadProduction;
        currentLookaheadProduction= "Value";
        scanToEnd= true;
        try {
            if (!check$Value()) return lastLookaheadSucceeded= false;
        }
        finally {
            popLookaheadStack();
            currentLookaheadProduction= prevProduction128;
        }
        return lastLookaheadSucceeded= true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$JSONObject() {
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:92:5
        if (!scanToken(OPEN_BRACE)) return lastLookaheadSucceeded= false;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for ZeroOrOne specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:93:5
        Token token129= currentLookaheadToken;
        if (!check$JSON_javacc$94$9()) currentLookaheadToken= token129;
        if (hitFailure||remainingLookahead<=0) return lastLookaheadSucceeded= !hitFailure;
        // Lookahead Code for RegexpRef specified at C:\Users\azerr\git\javacc21\examples\json\JSON.javacc:96:5
        if (!scanToken(CLOSE_BRACE)) return lastLookaheadSucceeded= false;
        return lastLookaheadSucceeded= true;
    }

    private boolean trace_enabled= false;
    public void setTracingEnabled(boolean tracingEnabled) {
        trace_enabled= tracingEnabled;
    }

    /**
 * @deprecated Use #setTracingEnabled
 */
    @Deprecated public void enable_tracing() {
        setTracingEnabled(true);
    }

    /**
 * @deprecated Use #setTracingEnabled
 */
    @Deprecated public void disable_tracing() {
        setTracingEnabled(false);
    }

    ArrayList<NonTerminalCall> parsingStack= new ArrayList<> ();
    private ArrayList<NonTerminalCall> lookaheadStack= new ArrayList<> ();
    /**
 * Inner class that represents entering a grammar production
 */
    class NonTerminalCall {
        final String sourceFile;
        final String productionName;
        final int line, column;
        // We actually only use this when we're working with the LookaheadStack
        final boolean scanToEnd;
        final EnumSet<TokenType> followSet;
        NonTerminalCall(String sourceFile, String productionName, int line, int column) {
            this.sourceFile= sourceFile;
            this.productionName= productionName;
            this.line= line;
            this.column= column;
            this.scanToEnd= JSONParser.this.scanToEnd;
            this.followSet= JSONParser.this.outerFollowSet;
        }

        StackTraceElement createStackTraceElement() {
            return new StackTraceElement("JSONParser", productionName, sourceFile, line);
        }

        void dump(PrintStream ps) {
            ps.println(productionName+":"+line+":"+column);
        }

    }
    private final void pushOntoCallStack(String methodName, String fileName, int line, int column) {
        parsingStack.add(new NonTerminalCall(fileName, methodName, line, column));
    }

    private final void popCallStack() {
        NonTerminalCall ntc= parsingStack.remove(parsingStack.size()-1);
        this.outerFollowSet= ntc.followSet;
    }

    private final void restoreCallStack(int prevSize) {
        while (parsingStack.size()> prevSize) {
            popCallStack();
        }
    }

    private final void pushOntoLookaheadStack(String methodName, String fileName, int line, int column) {
        lookaheadStack.add(new NonTerminalCall(fileName, methodName, line, column));
    }

    private final void popLookaheadStack() {
        NonTerminalCall ntc= lookaheadStack.remove(lookaheadStack.size()-1);
        this.scanToEnd= ntc.scanToEnd;
    }

    void dumpLookaheadStack(PrintStream ps) {
        ListIterator<NonTerminalCall> it= lookaheadStack.listIterator(lookaheadStack.size());
        while (it.hasPrevious()) {
            it.previous().dump(ps);
        }
    }

    void dumpCallStack(PrintStream ps) {
        ListIterator<NonTerminalCall> it= parsingStack.listIterator(parsingStack.size());
        while (it.hasPrevious()) {
            it.previous().dump(ps);
        }
    }

    void dumpLookaheadCallStack(PrintStream ps) {
        ps.println("Current Parser Production is: "+currentlyParsedProduction);
        ps.println("Current Lookahead Production is: "+currentLookaheadProduction);
        ps.println("---Lookahead Stack---");
        dumpLookaheadStack(ps);
        ps.println("---Call Stack---");
        dumpCallStack(ps);
    }

    public boolean isParserTolerant() {
        return false;
    }

    public void setParserTolerant(boolean tolerantParsing) {
        if (tolerantParsing) {
            throw new UnsupportedOperationException("This parser was not built with that feature!");
        }
    }

    private Token consumeToken(TokenType expectedType) throws ParseException {
        Token oldToken= lastConsumedToken;
        Token nextToken= nextToken(lastConsumedToken);
        if (nextToken.getType()!=expectedType) {
            nextToken= handleUnexpectedTokenType(expectedType, nextToken);
        }
        this.lastConsumedToken= nextToken;
        this.nextTokenType= null;
        if (buildTree&&tokensAreNodes) {
            pushNode(lastConsumedToken);
        }
        if (trace_enabled) LOGGER.info("Consumed token of type "+lastConsumedToken.getType()+" from "+lastConsumedToken.getLocation());
        return lastConsumedToken;
    }

    private Token handleUnexpectedTokenType(TokenType expectedType, Token nextToken) throws ParseException {
        throw new ParseException(nextToken, EnumSet.of(expectedType), parsingStack);
    }

    private class ParseState {
        Token lastConsumed;
        ArrayList<NonTerminalCall> parsingStack;
        NodeScope nodeScope;
        ParseState() {
            this.lastConsumed= JSONParser.this.lastConsumedToken;
            this.parsingStack= (ArrayList<NonTerminalCall> ) JSONParser.this.parsingStack.clone();
            this.nodeScope= (NodeScope) currentNodeScope.clone();
        }

    }
    private boolean buildTree= true;
    private boolean tokensAreNodes= true;
    private boolean unparsedTokensAreNodes= false;
    public void setUnparsedTokensAreNodes(boolean unparsedTokensAreNodes) {
        this.unparsedTokensAreNodes= unparsedTokensAreNodes;
    }

    public void setTokensAreNodes(boolean tokensAreNodes) {
        this.tokensAreNodes= tokensAreNodes;
    }

    NodeScope currentNodeScope= new NodeScope();
    /** 
	 * Returns the root node of the AST.  It only makes sense to call
	 * this after a successful parse. 
	 */
    public Node rootNode() {
        return currentNodeScope.rootNode();
    }

    /**
     * push a node onto the top of the node stack
     */
    public void pushNode(Node n) {
        currentNodeScope.add(n);
    }

    /** 
     * Returns the node on the top of the stack, and remove it from the
     * stack.  
     */
    public Node popNode() {
        return currentNodeScope.pop();
    }

    /** 
     * Returns the node currently on the top of the stack. 
     */
    public Node peekNode() {
        return currentNodeScope.peek();
    }

    /**
     * Puts the node on the top of the stack. However, unlike pushNode()
     * it replaces the node that is currently on the top of the stack.
     * This is effectively equivalent to popNode() followed by pushNode(n)
     */
    public void pokeNode(Node n) {
        currentNodeScope.poke(n);
    }

    /** Returns the number of children on the stack in the current node
	 * scope. 
	 */
    public int nodeArity() {
        return currentNodeScope.size();
    }

    public void clearNodeScope() {
        currentNodeScope.clear();
    }

    public void openNodeScope(Node n) {
        new NodeScope();
        if (n!=null) {
            Token next= nextToken(lastConsumedToken);
            n.setBeginLine(next.getBeginLine());
            n.setBeginColumn(next.getBeginColumn());
            n.setInputSource(this.getInputSource());
            n.open();
        }
        if (trace_enabled&&n!=null) LOGGER.info("Opened node scope for node of type: "+n.getClass().getName());
        if (trace_enabled) LOGGER.info("Scope nesting level is "+currentNodeScope.nestingLevel());
    }

    /* A definite node is constructed from a specified number of
	 * children.  That number of nodes are popped from the stack and
	 * made the children of the definite node.  Then the definite node
	 * is pushed on to the stack.
	 */
    public void closeNodeScope(Node n, int num) {
        n.setEndLine(lastConsumedToken.getEndLine());
        n.setEndColumn(lastConsumedToken.getEndColumn());
        if (trace_enabled) LOGGER.info("Closing node scope for node of type: "+n.getClass().getName()+", popping "+num+" nodes off the stack.");
        currentNodeScope.close();
        ArrayList<Node> nodes= new ArrayList<Node> ();
        for (int i= 0; i<num; i++) {
            nodes.add(popNode());
        }
        Collections.reverse(nodes);
        for (Node child : nodes) {
            // FIXME deal with the UNPARSED_TOKENS_ARE_NODES case
            n.addChild(child);
        }
        n.close();
        pushNode(n);
    }

    /**
	 * A conditional node is constructed if the condition is true.  All
	 * the nodes that have been pushed since the node was opened are
	 * made children of the conditional node, which is then pushed
	 * on to the stack.  If the condition is false the node is not
	 * constructed and they are left on the stack. 
	 */
    public void closeNodeScope(Node n, boolean condition) {
        if (n!=null&&condition) {
            n.setEndColumn(lastConsumedToken.getEndColumn());
            n.setEndLine(lastConsumedToken.getEndLine());
            if (trace_enabled) LOGGER.finer("Closing node scope for node of type: "+n.getClass().getName()+", popping "+nodeArity()+" nodes off the stack.");
            int a= nodeArity();
            currentNodeScope.close();
            ArrayList<Node> nodes= new ArrayList<Node> ();
            while (a--> 0) {
                nodes.add(popNode());
            }
            Collections.reverse(nodes);
            for (Node child : nodes) {
                if (unparsedTokensAreNodes&&child instanceof Token) {
                    Token tok= (Token) child;
                    while (tok.getPreviousToken()!=null&&tok.getPreviousToken().isUnparsed()) {
                        tok= tok.getPreviousToken();
                    }
                    while (tok.isUnparsed()) {
                        n.addChild(tok);
                        tok= tok.getNextToken();
                    }
                }
                n.addChild(child);
            }
            n.close();
            if (trace_enabled) {
                LOGGER.info("Closing node scope for node of type: "+n.getClass().getName()+", leaving "+nodeArity()+" nodes on the stack.");
                LOGGER.info("Nesting level is : "+currentNodeScope.nestingLevel());
            }
            pushNode(n);
            if (trace_enabled) {
                LOGGER.info("Closed node scope for node of type: "+n.getClass().getName()+", there are now "+nodeArity()+" nodes on the stack.");
                LOGGER.info("Nesting level is : "+currentNodeScope.nestingLevel());
            }
        }
        else {
            currentNodeScope.close();
            if (trace_enabled&&n!=null) {
                LOGGER.info("Closed node scope for node of type: "+n.getClass().getName()+", leaving "+nodeArity()+" nodes on the stack.");
                LOGGER.info("Nesting level is : "+currentNodeScope.nestingLevel());
            }
        }
    }

    public boolean getBuildTree() {
        return buildTree;
    }

    public void setBuildTree(boolean buildTree) {
        this.buildTree= buildTree;
    }

    /**
     * Just a kludge so that existing jjtree-based code that uses
     * parser.jjtree.foo can work without change.
     */
    JSONParser jjtree= this;
    @SuppressWarnings("serial")
    class NodeScope extends ArrayList<Node>  {
        NodeScope parentScope;
        NodeScope() {
            this.parentScope= JSONParser.this.currentNodeScope;
            JSONParser.this.currentNodeScope= this;
        }

        boolean isRootScope() {
            return parentScope== null;
        }

        Node rootNode() {
            NodeScope ns= this;
            while (ns.parentScope!=null) {
                ns= ns.parentScope;
            }
            return ns.isEmpty()?null:
            ns.get(0);
        }

        Node peek() {
            return isEmpty()?parentScope.peek():
            get(size()-1);
        }

        Node pop() {
            return isEmpty()?parentScope.pop():
            remove(size()-1);
        }

        void poke(Node n) {
            if (isEmpty()) {
                parentScope.poke(n);
            }
            else {
                set(size()-1, n);
            }
        }

        void close() {
            parentScope.addAll(this);
            JSONParser.this.currentNodeScope= parentScope;
        }

        int nestingLevel() {
            int result= 0;
            NodeScope parent= this;
            while (parent.parentScope!=null) {
                result++;
                parent= parent.parentScope;
            }
            return result;
        }

        public NodeScope clone() {
            NodeScope clone= (NodeScope) super.clone();
            if (parentScope!=null) {
                clone.parentScope= (NodeScope) parentScope.clone();
            }
            return clone;
        }

    }
}
